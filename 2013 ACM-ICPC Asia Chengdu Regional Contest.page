# Contest Info

date: 2017.08.02 10:00-15:00

[practice link](https://cn.vjudge.net/contest/175533)

# Solutions

## C. Clumsy Algorithm

**题目大意**：给你一个 $1 \sim n$  的排列 $p$ ，定义一次操作为交换 $p_{i}, p_{j}(i \not= j)$ ，代价为 $2|i-j|-1$ .定义 $f(p)$ 表示将 $p$ 变成顺序排列的最小代价， $g(p)$ 定义为 $\sum_{i=1}^{n}\mathrm{max}(0,i-p_{i})$ ，现在给定 $p$ 的长度为 $k$ 的前缀，问满足 $f(p)=g(p)$ 的排列有多少种。

**题解**：先证明 $f(p)$ 就是 $p$ 的逆序数。对任何交换 $i,j(i<j)$ 的操作，我们都可以通过依次进行 $(i,i+1), \cdots, (j-2, j-1), (j-1, j), (j-1, j-2), \cdots,(i+1,i)$ 来代替，代价是 $2|i-j|-1$ ，故最优解一定可以通过交换相邻元素得到。容易证明最小代价就是 $p$ 的逆序数。 
$$
\begin{aligned}\\
f(p)&=\sum_{i=1}^{n}\sum_{j=i+1}^{n}[p_{i}>p_{j}]\\
&=\sum_{i=1}^{n}i-\sum_{i=1}^{n}p_{i}+\sum_{i=1}^{n}\sum_{j=i+1}^{n}[p_{i}>p_{j}]\\
&=\sum_{i=1}^{n}(i-p_{i}+\sum_{j=i+1}^{n}[p_{i}>p_{j}])\\
\end{aligned}\\
$$

显然所有小于等于 $p_{i}$ 的数都给 $i+\sum_{j=i+1}^{n}[p_{i}>p_{j}]$ 做了 $1$ 的贡献，所以有 $i-p_{i}+\sum_{j=i+1}^{n}[p_{i}>p_{j}]\ge \mathrm{max}(0,i-p_{i})$ 。要求 $f(p)=g(p)$ ，即要求对于每个 $i$ 有 $i-p_{i}+\sum_{j=i+1}^{n}[p_{i}>p_{j}] = \mathrm{max}(0,i-p_{i})$ ，若 $i-p_{i}<0$ ，等价于 $p_{i}$ 左边的都小于 $p_{i}$ ，若 $i-p_{i}\ge 0$ ，等价于比 $p_{i}$ 小的都在 $p_{i}$ 左边，即要求 $p$ 的每一个位置都满足前述两个要求之一（这和最长下降子序列长度小于等于 $2$ 是等价的）。我们用 $dp$ 来计数。不考虑前缀，设 $dp[i][j]$ 表示 $\max\limits_{1 \le k \le i}p_{k}=j$ 的方案数，则转移方程为：

$$
dp[i][j]=
\left\{
\begin{aligned}
&1,&i=j=0\\
&\sum_{k=0}^{j-1}dp[i-1][k]+[i\ge j]dp[i-1][j],&\mathrm{others}\\
\end{aligned}
\right.
$$

最后考虑前缀，容易发现这是唬人的。按照刚刚说的验证一下就好了。复杂度 $O(n^{3})$ 。

[C++ Code](http://paste.ubuntu.com/25233635/)

## H. Hard Disk Drive

签到题

## J. Just Random

**题目大意**：求 $\displaystyle \sum_{i=a}^{b}\sum_{j=c}^{d}[i+j\equiv m(\mathrm{mod}\ p)]$。

**题解**：直接算不太好算，但是转化为求 $ans([0,b], [0,d])-ans([0, a-1], [0,d])-ans([0,b], [0, c-1])+ans([0,a-1], [0,c-1])$ 以后，每一个就好算了。

[C++ Code](http://paste.ubuntu.com/25233652/)

# Replay and Summary

## Replay

补充训练赛惯例在校车上开题，看了两眼就对这场比赛有了一个直观的印象：题面很长。。。

W 先看的 J，然后发现是一道似乎不是很难的数学题，推一推式子就可以了，就交给了 Z。Z 说到机房就能写，然后说 H 是签到题（正好是 W 觉得太长不看的题）。

于是到机房之后 Z 先 A 了 H，然后没过多久也 A 了 J。 

W 在车上就看了 G，跟 D 讨论了一下，感觉用两个 ac 自动机，然后根号暴力合并求 fail 似乎可行。于是 W 到了机房就开始写 G。结果吃完饭都还没过。后来检讨了一下暴力合并的 ac 自动机显然不能写成 trie 图，而且指针的写法也不够优秀，梦回数组。调试了几发就开心地拿到了一血。

然后 W 感性理解了一下 F 的过题人数，觉得直接最小最大生成树搞一下，然后傻逼地没处理无解，感人肺腑。

然后 Z 据说猜了一个 C 的结论，wa 了一发之后静态看了看代码然后过掉了。又是一血很开心。

W 之前理解错了 A 的题意，写了个垃圾玩意儿交了几发，看 Z 没事情做就叫过来一起看题。然后发现自己傻逼了，正确理解题意之后也很快过掉了。

D 从到机房开始一直刚 B，期间 wa 了几发。W 帮他造了数据之后发现是没处理 text 中的 /。检讨了一下以后应该相互出数据，也过掉了。

总的来说这场还是不错，就是以后补充训练应该更紧张一点，在现场赛之前应该抓住每一场训练的机会。

## coldwater

这场做了 AFG，罚时比较爆炸。对 ac 自动机还是不够熟练，明明要暴力合并重建，一开始还写了一个指针的 trie 图，感觉很智障。然后 A 读错了题也需要背锅。这场没有监督队友紧张起来，场面一度十分休闲，导致 D 题被 A 穿了然而竟然没人读题。最后四十分钟秉持着不能放弃地原则把 D 题磕磕绊绊读完了然而还是没什么想法，样例也没有在草稿纸上通过。以后还是要监督队友，关心一下进度，把锅分好。

## ShinriiTin

在校车上读了 A 和 B 的题面，感觉题目很长很烦，懒得去读其它题了，就先开了 B ，写完之后交 wa 了， 调了很久也没有找到 wa 的原因，最后 W 从某个网页上扒下来源代码试了下，发现我处理 tag 的时候如果里面有很多个 / ，我会把它判为 blank tag，然后改掉就 a 了，然后发现队友们已经做完六道题了，于是这场就摸的透彻啊。 其实那个 wa 点在题面中的 example 里就已经出现了，但是没在样例里面我就没有用来测试，以后 debug 的时候这种例子也应该全都用上。还有就是正式的比赛就不能像今天这样死磕一道题了，要合理分配时间，有问题多和队友交流。

## zhongzihao

这场题面可以说是又臭又长，看着难受。先是写了签到题 H ，然后 J 是个很水的计数也很快过掉了，后面我的题有 C 和 E ，C 题猜了个结论莫名其妙就 A 了，连我自己都不知道是怎么想到的，最后还有个计算几何 E 不会，这个也是比较遗憾的，进一步说明了我计算几何太菜，以后还是要加油。