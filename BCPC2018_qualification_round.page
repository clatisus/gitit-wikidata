# Solutions

## A. 两等分的 Alice

$dp[i][j][k]$ 表示考虑了前 $i$ 段时间，kirito 的时间减去 ugo 的时间为 $j*a+k$，Alice 最少单独练习的时间。注意空间限制，$i$ 这一维要滚动。

实现的时候 $j,k$ 两维可能为负数，加上一个 offset 即可。时间复杂度 $\mathcal{O}(n^2(b-a)^2)$。

## B. 升级超梦

题目定位：签到题 1/3.

二分/枚举答案，然后贪心 check。把消耗最多的 $n$ 级用神奇糖果，判断剩下需要的经验是否不超过 $m$。

## D. Bella 姐姐发辣条

题目定位：签到题 2/3.

如果第一个小朋友辣条确定了，那么第 $i$ 个小朋友也确定了。设第 $i$ 个小朋友辣条为 $c_i = c_1 + \sum_{j = 1}^{i-1}b_j$。要满足 $c_i\ge a_i$，解一下关于 $c_1$ 的不等式组。

## E. 禁忌的共鸣

题目定位：简单题

做法：枚举倍数 + 并查集

读题发现是最大生成树（最小生成树），但是直接建图是个完全图，$n^2$ 条边时间和空间都不够的。因此需要思考一下不直接建边有没有方式来完成生成树。

求的是最大生成树，不妨多连几条边，把两两间所有可能的因子，全部各自作为边权，连出来一条边。这样做不会影响答案。根据 Kruskal 算法的思想，我们首先考虑最大的因子 $d$。会发现以 $d$ 为边权的边，其生成子图是个完全图。即是说只要知道哪些 $a_i$ 带有这个最大的因子 $d$，随便一种方案将这些点连起来，边权为 $d$ 的所有边就全部正确地处理掉了。

接下来不断迭代，从大到小枚举因子，再合并有这些因子的点，即可类同 Kruskal 算法的过程完成最大生成树。

简明地说，就是维护一个并查集。从大到小枚举 $d$，再枚举 $d$ 的所有倍数 $kd$，对某个 $d$，将所有 $a_i = kd$ 不在同一个集合的点，以边权为 $d$ 连接，并维护、合并这些集合。

点权相同的点会首先在枚举 $d$ 为 $a_i$ 时合并掉，所以可以提前合并掉点权相同的点。答案是 $\mathcal{O}(n^2)$ 的，要 $64$ 位整数存答案。

那这样的算法复杂度究竟是什么级别呢？

$$T(n) = \alpha(n) \sum_{i=1}^{\max a_i} \frac{\max a_i}{i}$$

可以用积分解出来那个求和式的上下界，最终 $T(n) = \mathcal{O}(\max(a_i) \log(\max(a_i)) \alpha(n))$。$\max(a_i)$ 实际与 $n$ 同阶。

所以，每个测试点时间复杂度 $\mathcal{O}(n \log(n) \alpha(n))$，常数奇小（因为这个 $\log$ 在推导的 $T(n)$ 中是个自然数为底的）。空间复杂度 $\mathcal{O}(n)$。
