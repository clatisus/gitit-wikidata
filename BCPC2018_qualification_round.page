# General

[比赛链接](https://buaacoding.cn/contest-ng/index.html#/334)

# Solutions

## A. 两等分的 Alice

$dp[i][j][k]$ 表示考虑了前 $i$ 段时间，kirito 的时间减去 ugo 的时间为 $j*a+k$，Alice 最少单独练习的时间。注意空间限制，$i$ 这一维要滚动。

实现的时候 $j,k$ 两维可能为负数，加上一个 offset 即可。时间复杂度 $\mathcal{O}(n^2(b-a)^2)$。

## B. 升级超梦

题目定位：签到题 1/3.

二分/枚举答案，然后贪心 check。把消耗最多的 $n$ 级用神奇糖果，判断剩下需要的经验是否不超过 $m$。

## C. 小张的魔法跳越

出题人咕咕中。

[验题人 Immortal.S 的代码](https://paste.ubuntu.com/p/FqfgNHHw4Y/)

## D. Bella 姐姐发辣条

题目定位：签到题 2/3.

如果第一个小朋友辣条确定了，那么第 $i$ 个小朋友也确定了。设第 $i$ 个小朋友辣条为 $c_i = c_1 + \sum_{j = 1}^{i-1}b_j$。要满足 $c_i\ge a_i$，解一下关于 $c_1$ 的不等式组。

## E. 禁忌的共鸣

题目定位：简单题

做法：枚举倍数 + 并查集

读题发现是最大生成树（最小生成树），但是直接建图是个完全图，$n^2$ 条边时间和空间都不够的。因此需要思考一下不直接建边有没有方式来完成生成树。

求的是最大生成树，不妨多连几条边，把两两间所有可能的因子，全部各自作为边权，连出来一条边。这样做不会影响答案。根据 Kruskal 算法的思想，我们首先考虑最大的因子 $d$。会发现以 $d$ 为边权的边，其生成子图是个完全图。即是说只要知道哪些 $a_i$ 带有这个最大的因子 $d$，随便一种方案将这些点连起来，边权为 $d$ 的所有边就全部正确地处理掉了。

接下来不断迭代，从大到小枚举因子，再合并有这些因子的点，即可类同 Kruskal 算法的过程完成最大生成树。

简明地说，就是维护一个并查集。从大到小枚举 $d$，再枚举 $d$ 的所有倍数 $kd$，对某个 $d$，将所有 $a_i = kd$ 不在同一个集合的点，以边权为 $d$ 连接，并维护、合并这些集合。

点权相同的点会首先在枚举 $d$ 为 $a_i$ 时合并掉，所以可以提前合并掉点权相同的点。答案是 $\mathcal{O}(n^2)$ 的，要 $64$ 位整数存答案。

那这样的算法复杂度究竟是什么级别呢？

$$T(n) = \alpha(n) \sum_{i=1}^{\max a_i} \frac{\max a_i}{i}$$

可以用积分解出来那个求和式的上下界，最终 $T(n) = \mathcal{O}(\max(a_i) \log(\max(a_i)) \alpha(n))$。$\max(a_i)$ 实际与 $n$ 同阶。

所以，每个测试点时间复杂度 $\mathcal{O}(n \log(n) \alpha(n))$，常数奇小（因为这个 $\log$ 在推导的 $T(n)$ 中是个自然数为底的）。空间复杂度 $\mathcal{O}(n)$。

## F. zzh 与同余方程

该题等价于对 $\forall i=1,\cdots,n$，求 $(i+1)^{i+1}-(i+1)^{i}=(i+1)^{i}\cdot i$ 的约数个数之和。对数论不太熟悉的同学可以先看[这里](https://zh.wikipedia.org/wiki/%E5%9B%A0%E6%95%B8#%E5%9B%A0%E6%95%B0%E4%B8%AA%E6%95%B0)了解一下基本知识。

设 $i$ 的唯一分解为 $\prod_{i=1}^{n}p_{i}^{a_{i}}$，$i+1$ 的唯一分解为 $\prod_{i=1}^{m}p_{i}'^{a_{i}'}$。由于 $i$ 和 ​$i+1$ 互质，因此 ​$(i+1)^{i}\cdot i$ 的约数个数即为 ​$\prod_{i=1}^{m}a_{i}'\cdot\prod_{i=1}^{n}ia_{i}$。

记 $A=10^{7}$。使用线性的[欧拉筛](https://blog.csdn.net/lytning/article/details/24432651)可以在 $\mathcal{O}(A)$ 的时间内求出 $1\sim A$ 中每个整数的最小质因子及其数量。对于每个 $i$，我们不断地把它最小的质因子除掉，就可以在 $\mathcal{O}(\omega(i))$ 的时间内得到 $i$ 的唯一分解，从而可以计算出上面的式子。

虽然本题有 $T=10^{6}$ 组数据，但是我们可以从 $1$ 到 $10^{7}$ 依次计算，在计算的过程中把 $1,\cdots,10^{7}$ 的答案储存下来。这样对每个询问就可以 $\mathcal{O}(1)$ 回答了。

时间复杂度 $\sum_{i=1}^{A}\mathcal{O}(\omega(i))=\mathcal{O}(A\log\log A)$。这一时间复杂度的证明参见 [Mertens' second theorem](https://en.wikipedia.org/wiki/Mertens%27_theorems)。

## G. 小 z 刷题。

题目定位：咕咕咕

首先考虑普通的上升子序列之和怎么做。假设原数列是 $A$, 考虑 $dp[i]$ 代表以 $i$ 这个位置结尾的子序列个数，那么很容易列出 $dp[i]=\sum_{j \lt i} dp[j] [A[j]\lt A[i]]$ ，这应该是个经典题。如果知道了这个关系，那么在线用一个树形结构维护 $A[j]$ 的 $dp$ 值，就可以在 $O(nlogn)$ 的时间复杂度内求出上升子序列长度之和的答案。数字个数起到的作用仅有乘个系数而已。

在此基础上考虑次方和该怎么求。对于 $k​$ 次方来说，假设某个序列的最末尾数字是 $A[i]​$ ，而且序列长度为 $l+1​$ ，那么我们可以通过 $(l+1)^k = \sum_i C_k^i * l^i​$ 来从前方获得答案。也就是说，我们通过一个树状数组或其他的树形结构维护到 $i​$ 这个位置为止，以 $i​$ 结尾的 $0​$ 次到 $k​$ 次方和，就可以通过 $dp[i][l]=\sum_{j \lt i} [A[j]\lt A[i]] \sum_k^l C_l^k * dp[j] [k]​$ 来获得答案。同样，数字个数起到的作用仅有乘个系数而已

其中$[A[j]<A[i]]​$ 是当且仅当里面等式成立的意思。这个辣鸡数据结构貌似并没有太多细节坑点。

复杂度 $O(nklogn + nk^2)$

思考题：如果题面变成 "求不下降子序列 $k​$ 次方和" 该怎么求呢？数据范围可以不变。(本来想出这个，然后想到要降低难度就降了一点难度) 

## H. Draw 顺小王子

题目定位：签到题 3/3.

枚举剩余手牌的两两组合，check 即可。

## I. Ange 的 DNA 自动机


注意到四阶群只有两个，循环群和 Klein 群。而题目中描述的矩阵，正是 Klein 群的矩阵表示，注意到 Klein 群是可交换的非循环群。我们仅考虑他的基本性质，结合律。事实上，只要**验证所给的运算是满足结合律的**，可以进行倍增，方案如下:

记 $b_i^{k}$ 表示第 $k$ 次运算后第 $i$ 个位置的结果，那么

$$b_i^{2^s} = b_i^{2^{s-1}} \times b_{i+2^{s-1}}^{2^{s-1}}$$

事实上，Klein群的乘法表是：

$$
\begin{matrix}
 \times &0 &1 &2 &3\\
 0 &0 &1 &2 &3\\
 1 &1 &0 &3 &2\\
 2 &2 &3 &0 &1\\
 3 &3 &2 &1 &0\\
\end{matrix}
$$


其实是简单的异或运算。对于每组数据的时间复杂度 $\mathcal{O}(n \log n)$ 或 $\mathcal{O}(\frac{n \log n}{64})$，时限充足是标程的三倍，验题人的五倍。

## J. 大丁的煤气灶

这其实是一个多重集合的组合问题。即，在 $n$ 种物品中选 $m$ 个的方案数。

当每种物品能选的个数为无限个时，方案数为 ${n+m-1 \choose m}$

当每种物品有个数限制时，我们采用容斥来解决

设 $ans_i$ 为第 $i$ 种物品有个数限制而选择都超过限制时的方案数，则

$$ans=(ans_空)+(-ans_1-ans_2-...-ans_n)+(ans_{1,2}+ans_{1,3}+...+ans_{n-1,n})-....​$$

有些物品有限制的方案数为 ${n+m-1-sum\choose m-sum}$

其中，$sum$ 为 $\sum（每种物品限制的个数+1）$，即，我们要求的是不满足任何一个限制的方案数。

比如对于样例 $n=2,m=3​$。




\begin{aligned}
ans&={n+m-1\choose m}-{n+m-v_1-1\choose m-v_1-1}-{n+m-v_2-1\choose m-v_2-1}+{n+m-v_1-1-v_2-1\choose m-v_1-1-v_2-1}\\

​&=C_4^3-C_2^1-C_0^{-1}+C_{-2}^{-3}\\

​&=4-2-0+0=2\\
\end{aligned}




然后就是算组合数的问题了

对于每个模数算个值然后用中国剩余定理算回来

由于模数可能会小，所以可能找不到逆元

因此只能用卢卡斯定理递归计算每个组合数

注意中国剩余定理合并答案的时候会爆 LL，可以用快速乘或者int128解决

时间复杂度大概 $\mathcal{O}(2^nk*\log_2 m*T)$。



ps：这题解不是出题人写的，是善良可爱的zyy写的，轻喷

## K. wjj 的自动售货机

注意当 $b\ge a$ 的时候，有 $b\bmod a<\frac{b}{2}$。所以每个数字只会操作 $\log C$ 次，其中 $C$ 是数字的值域。我们只需要用一个链表/并查集将 $0$ 缩起来，维护每个位置右边第一个非 $0$ 的位置，就可以暴力做每次操作了。

复杂度 $\mathcal{O}(n\log C)$。（没卡线段树）。

## L. Auto Chess

易知，若回合 $i$ 不能凑齐棋子,则对于 $\forall j, j < i$ ，回合 $j$ 不能凑齐棋子，显然答案具有单调性。

由于利息的存在，肯定是在尽量晚的情况下购买，所以整道题的解法为二分答案，用尽量晚买的策略模拟游戏过程判断。时间复杂度 $\mathcal{O}(nm\log n)​$。

