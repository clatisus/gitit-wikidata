# Contest Info

date: 2019.04.27 14:33-19:33

[practice link](http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=6307)

# Solutions

## B. Boss Battle

签到题。

## C. Connect the Dots

**题目大意**：给你一些平面上的带标号整点，要求你用段数尽可能少的**一条**折线段将它们**按顺序**连起来（类似于解锁手机屏幕），求最小段数。

**题解**：贪心。记 $f_{i}$ 表示到第 $i$ 个点时最少的段数，$S_{i}$ 表示达到最小段数可能的入射角集合。

转移时，假如 $p_{i+1}-p_{i}\in S_{i}$，那么一定会选择这种方案（后面证明），即 $f_{i+1}=f_{i},S_{i+1}={p_{i+1}-p_{i}}$；否则的话，线段可以先沿着原方向走任意长的一段距离，然后再拐弯到 $p_{i+1}$，即 $f_{i+1}=f_{i}+1$，$S_{i+1}$ 是一个区间，区间具体的范围需要一定的讨论，这里就不展开说了。

上面的证明也比较简单，因为第一种情况少了一段，所以它可以在 $p_{i+1}$ 处旋转任意的角度（开始新的一段），可以认为这和第二种情况中 $S_{i+1}=[0,2\pi)$ 是等价的。因此第一种情况必然更优。

## F. Factor-Free Tree 

**题目大意**：定义`Factor-Free Tree`为一棵二叉树，且每个节点有一个正整数，满足任意一对有祖先关系的节点对应的正整数互质。给出长度为$n\le10^6$的数列$1\le a_i\le10^7$，构造一棵`Factor-Free Tree`满足中序遍历序列是$\{a_n\}$，有解输出任意，否则输出`impossible`。

**题解**：

*solution1*：

首先`Factor-Free Tree`的约束等价于每个节点和子树中其他节点互质，而中序遍历中一棵子树对应一个区间。

预处理$10^7$以内的质数和最小质因子，可以求出每个位置与它互质的极大区间，这一部分的复杂度为$O(A+n\log{A})$，其中$A$为$a_i$的范围。

考虑按中序遍历的顺序增量构造合法的`Factor-Free Tree`，像维护笛卡尔树一样，维护一条右链。

如果当前想要加入的点$i$，可以覆盖的右端点，比当前右链可以覆盖的右端点（取决于这条链上的最小值）要远，那么显然尽可能地把点$i$放到深度小的地方更优（能不能放上去取决于$i$要踢掉的这一棵子树中最左的点是否能被$i$所覆盖，如果可以一直换到令链上的最小值发生变化，显然是优的，否则，替换一部分下去，对于之后想要做同样操作的$j$，也不会加强对其的限制，因此就大力踢就行了）。

然后如果右链不为空，需要检查一下$i$是否可以作为最后一个节点的右儿子，如果不行就无解。

维护右链能覆盖的右端点最小值，因为一旦加入右链，祖先关系就一直存在，就每次加入的时候和父亲的右端点取最小值就可以了。

构造部分的时间复杂度为$O(n)$.

总的时间复杂度为$O(A+n\log{A})$.

*solution2*：

首先位置$i$可以作为区间$[l,r]$的根的必要条件是$i$与区间内其他位置都互质。

对于区间$[l,r]$，如果只有一个这样的位置，那么我们别无选择；否则假设有两个以上的位置，选任意一个都不影响最终的可行性。

假设$u$和$v$是两个不同的合法位置，那么$u$和$v$将其切成三段，最坏也有将$u$和$v$直接相连的方法使得这三段独立，如果这三段不是分别有解，则必然导致无解（如果是某一段绑定在一起不能处理的话，想要补救只能从某个位置断开，然后可以断开又必须要求这个位置可以覆盖整个区间，与它不能处理矛盾）；在分别有解的情况下，显然$u$和$v$选哪一个都不影响。

因此，我们可以从$[1,n]$开始选择一个合法的位置作为根，然后递归处理左右。

在处理$[l,r]$时，可以从两个端点开始同步向内枚举，显然最终的时间复杂度是$O(n\log{n})$的，可以考虑最终的分治树，每一层的复杂度是$O(min(siz[lch],siz[rch]))$，因此本质上是个启发式合并的逆过程。

加上预处理互质区间的部分，总的时间复杂度为$O(A+n\log{A}+n\log{n})$.

## G. Glyph Recognition

**题目大意**：给出平面上$n\le1000$个整点。对于$3\le k\le8$的正$k$边形，将其中心放在原点，其中一个顶点放在$x$正半轴，定义其顶点到原点的半径为$R_k$，求一个最大的$R_{k1}$使得这$n$个点都不在其内部，求一个最小的$R_{k2}$使得这$n$个点都在其内部，则$\displaystyle score_k=\frac{R_{k1}^2}{R_{k2}^2}$。输出$arg\_max(score_k)$和$max(score_k)$.

**题解**：对于每个点，求出其刚好落在边界上的$R$，然后取最小值为$R_1$，取最大值为$R_2$。计算$R$的时候，可以利用`fmod`将其旋转到正多边形以原点为中心的三角剖分的第一块区域，然后解一下三角形即可。时间复杂度$O(nk)$.

二分也可以，但是精度比较差，`Claris`用二分过了，但是我反正是`wa54`。

## H. High Score

**题目大意**：给出 $a,b,c,d\ge0$，要你把 $d$ 分配给 $a,b,c$，使得 $a^{2}+b^{2}+c^{2}+7\min\{a,b,c\}$ 最大，求这个最大值。

**题解**：枚举最小值，把 $a,b,c$ 都提升到最小值后，显然剩余的 $d$ 全分给最大值最优，那么最终答案是一个关于最小值的（分三段的）二次函数，分别求最值即可。

题解说每段暴力算最小的几个值就好了。。不是很懂

## K. Knockout Tournament 

**题目大意**：定义$n\le4096$的淘汰赛为，第一轮$k$人轮空，剩余$n-k$人两两一组进行一场淘汰，第一轮结束后剩下的人数恰好是$2$的幂次，之后每一轮两两一组进行淘汰直到只剩下一个人。每个人有一个能力值$a_i$，如果第$i$个人和第$j$个人进行一场淘汰，则$i$获胜的概率为$\displaystyle \frac{a_i}{a_i+a_j}$. 在比赛开始前，任意安排好整个赛程，使得第一个人获胜的概率最大，求第一个人获胜的最大概率。

**题解**：首先令$m$为不大于$n$的最大的$2$的幂次，则$k=2m-n$. 将除了第一个人之外的人按$a_i$排序，将第一轮轮空的位置都放在左边，第一个人站第一个位置，剩下的人按$a_i$升序从左到右站，则第一个人获胜的概率最大。考虑用一个子树递推来计算这个概率，每个节点需要分别枚举左右子树中获胜的人来计算答案，时间复杂度$O(n^2)$. 用`std::unordered_map`来存储答案则空间复杂度为$O(n\log{n})$.