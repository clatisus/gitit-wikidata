# Contest Info

date: 2019.04.27 14:33-19:33

[practice link](http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=6307)

# Solutions

## F. Factor-Free Tree 

**题目大意**：定义`Factor-Free Tree`为一棵二叉树，且每个节点有一个正整数，满足任意一对有祖先关系的节点对应的正整数互质。给出长度为$n\le10^6$的数列$1\le a_i\le10^7$，构造一棵`Factor-Free Tree`满足中序遍历序列是$\{a_n\}$，有解输出任意，否则输出`impossible`。

**题解**：

*solution1*：

首先`Factor-Free Tree`的约束等价于每个节点和子树中其他节点互质，而中序遍历中一棵子树对应一个区间。

预处理$10^7$以内的质数和最小质因子，可以求出每个位置与它互质的极大区间，这一部分的复杂度为$O(A+n\log{A})$，其中$A$为$a_i$的范围。

考虑按中序遍历的顺序增量构造合法的`Factor-Free Tree`，像维护笛卡尔树一样，维护一条右链。

如果当前想要加入的点$i$，可以覆盖的右端点，比当前右链可以覆盖的右端点（取决于这条链上的最小值）要远，那么显然尽可能地把点$i$放到深度小的地方更优（能不能放上去取决于$i$要踢掉的这一棵子树中最左的点是否能被$i$所覆盖，如果可以一直换到令链上的最小值发生变化，显然是优的，否则，替换一部分下去，对于之后想要做同样操作的$j$，也不会加强对其的限制，因此就大力踢就行了）。

然后如果右链不为空，需要检查一下$i$是否可以作为最后一个节点的右儿子，如果不行就无解。

维护右链能覆盖的右端点最小值，因为一旦加入右链，祖先关系就一直存在，就每次加入的时候和父亲的右端点取最小值就可以了。

构造部分的时间复杂度为$O(n)$.

总的时间复杂度为$O(A+n\log{A})$.

*solution2*：

首先位置$i$可以作为区间$[l,r]$的根的必要条件是$i$与区间内其他位置都互质。

对于区间$[l,r]$，如果只有一个这样的位置，那么我们别无选择；否则假设有两个以上的位置，选任意一个都不影响最终的可行性。

假设$u$和$v$是两个不同的合法位置，那么$u$和$v$将其切成三段，最坏也有将$u$和$v$直接相连的方法使得这三段独立，如果这三段不是分别有解，则必然导致无解（如果是某一段绑定在一起不能处理的话，想要补救只能从某个位置断开，然后可以断开又必须要求这个位置可以覆盖整个区间，与它不能处理矛盾）；在分别有解的情况下，显然$u$和$v$选哪一个都不影响。

因此，我们可以从$[1,n]$开始选择一个合法的位置作为根，然后递归处理左右。

在处理$[l,r]$时，可以从两个端点开始同步向内枚举，显然最终的时间复杂度是$O(n\log{n})$的，可以考虑最终的分治树，每一层的复杂度是$O(min(siz[lch],siz[rch]))$，因此本质上是个启发式合并的逆过程。

加上预处理互质区间的部分，总的时间复杂度为$O(A+n\log{A}+n\log{n})$.

## G. Glyph Recognition

**题目大意**：给出平面上$n\le1000$个整点。对于$3\le k\le8$的正$k$边形，将其中心放在原点，其中一个顶点放在$x$正半轴，定义其顶点到原点的半径为$R_k$，求一个最大的$R_{k1}$使得这$n$个点都不在其内部，求一个最小的$R_{k2}$使得这$n$个点都在其内部，则$\displaystyle score_k=\frac{R_{k1}^2}{R_{k2}^2}$。输出$arg\_max(score_k)$和$max(score_k)$.

**题解**：对于每个点，求出其刚好落在边界上的$R$，然后取最小值为$R_1$，取最大值为$R_2$。计算$R$的时候，可以利用`fmod`将其旋转到正多边形以原点为中心的三角剖分的第一块区域，然后解一下三角形即可。时间复杂度$O(nk)$.

二分也可以，但是精度比较差，`Claris`用二分过了，但是我反正是`wa54`。