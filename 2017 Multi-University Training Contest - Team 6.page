# Contest Info

date 2017.08.10 12:00-17:00

[practice link](http://acm.hdu.edu.cn/search.php?field=problem&key=2017+Multi-University+Training+Contest+-+Team+6&source=1&searchmode=source)

# Solutions

## A. String

**题目大意**：给定一个有 $n$ 个单词的字典。给出 $q$ 次询问，每次询问给出两个字符串 $pre$ 和 $suf$，输出字典中有多少个单词以 $pre$ 为前缀，以 $suf$ 为后缀，并且不重叠。

**题解**：设字典中的单词为 $s_1, s_2, \dots, s_n$。构造一个串 $S= \text{#}s_1\text{@}s_1\text{#}\cdots \text{#}s_n\text{@}s_n\text{#}$。建立这个串的后缀自动机，并求出 parent 树的 dfs 序，用树状数组维护 dfs 序。每次询问的时候找到串 $suf\text{@}pre$ 对应的结点，求出子树和。

再考虑如何处理重叠的情况。很容易发现只有单词的长度小于  $len(pre)+len(suf)$ 的时候，才会出现重叠。我们把单词和询问都按照长度排序，枚举询问，在树状数组中删除不符合条件的单词。

有一个在线的做法，我们枚举每个长度，对小于等于这个长度的单词建立一个可持久化线段树维护 dfs 序。

## C. Inversion

**题目大意**：给出一个长度为 $2\leq n\leq10^5$ 的数组 $A$，$1\leq A_i \leq 10^9(1\leq i\leq n)$。数组 $B$ 满足 $B_i=\max\limits_{i \not\mid j} A_j$，$2\leq i \leq n$。输出 $B$ 数组。

**题解**：先将 $A$ 数组带着下标排个序，然后枚举 $i$ 再从大到小去找第一个不被 $i$ 整除的 $j$，则 $B_i=A_j$。时间复杂度 $\mathcal{O}(n\log n)$。

## L. Typesetting

**题目大意**：给一份需要插入一张图片的文章排版。行宽为 $W$，图片宽度为 $pw$，高度 $h$ 和插入位置未知，图片到左边缘间距为 $dw$。在插入的图片所占的 $h$ 行中，每行被分为左右两个部分，左边能容纳最多 $dw$ 个字符，右边能最多容纳最多 $W-dw-pw$ 个字符。并且：

- 单词不能被拆开放到两行，也不能被拆开放在图片左右两边
- 如果两个单词在同一行连续出现，中间间隔恰一个空格
- 不能改变单词的相对位置

给出 $W,pw,dw$，现在有一篇有 $n\leq 10^5$ 个单词的文章，每个单词的字符数 $1\leq a_i \leq W$。再给出 $q(q\leq 10^5)$ 次询问，每次给出图片插入的行 $x$ （如果直接排版文章所有单词所用的行数 $y < x-1$，那么图片实际上只能插入到第 $y+1$ 行）和图片的高度 $h$。求最少总行数。

**题解**：定义 $next(x,w)$ 为，从第 $x$ 个单词开始往 $w$ 个字符的块中，尽可能多的装单词，第一个不能被装下的单词。即 $\displaystyle next(x,w)=\min_y\left(y\geq x \land (y-x)+\sum\limits_{i=x}^{y} a_i >w\right)$。可以通过预处理 $a_i$ 的前缀和二分求解。

定义 $pre[i]$ 为插入图片前的 $i$ 行，最多能容纳到第几个单词。显然，$pre[0]=0$，$pre[i]=next(pre[i-1]+1,W)-1$。

再定义 $suf[i]$ 为插入图片后的第一个单词为 $i$ ，至少需要再使用多少行。显然 $suf[n+1]=0$，$suf[i]=suf[next(i,W)]+1$。

对于有插入图片的这些行，肯定是贪心地依次将左右两边都尽可能装满。对每个单词建两个点：$i$ 和 $i+n+1$，分别表示以 $i$ 作为插入了图片的某行的左边块的开始和右边块的开始。对于第 $i$ 个单词，令 $j=next(i,dw)$，则连一条 $j+n+1$ 到 $i$ 的边；令 $j_1=next(i,W-dw-pw)$，则连一条 $j_1$ 到 $i+n+1$ 的边。但是，还有几个特殊的情况：如果 $i=j \land i=j_1$ 说明 $i$ 太长了，有图片插入的行都无法容纳它，只能从图片后面的行继续放，这种情况我们不连任何边，$i$ 和 $i+n+1$ 两个点为根的树独立出来；如果 $i=j \lor i=j_1$，正常连边即可。这样就把这个贪心策略转换成了一个森林。

对于每个询问，我们找到 $pre[x-1]+1$ ，从这个点在对应的树中向上爬最多 $2h$ 层，就知道了图片后面的第一个单词 $y$，那么答案就是 $x-1+h+suf[y]$。向上爬的操作我们可以用倍增法来实现。

时空复杂度都是 $\mathcal{O}(n\log{n})$。

# Replay and Summary

## Replay

Z 一来就说 C 是一个 sb 题，然后写了一个 log 方的鬼东西，显然 tle 了。又加了一个输入优化，还是 tle 了，看来题是真的 sb。 D 拿过来想了想觉得可以 log 做，然后拿过来很快过掉了。

W 发现 K 题是一道似乎很简单的题啊，发现跟数学有一点点的关系就交给 Z 了，Z 很快 1a 了。D 和 W 开始看 H 和 A 这两道字符串的题。在 H 卡了很久没想出怎么做。Z 在刚 B 和 G 这两道计算几何和数学题。

W 上了个厕所之后发现 H 挺逗你玩的，直接扫几遍就行了。过了之后继续想 A。A 其实已经想的差不多了，就差处理前后缀交叉的情况。想了想离线排序就可以做了。直接开始写后缀自动机，然后 wa 了之后看了看代码发现很多细节错误，数组开小，以及有一个 ++j 迷之写成 --j。改了之后也过了。

之后就很僵硬了。D 和 Z 在做 J 这道博弈，然后很果断地觉得删边是没有用的，直接不断删掉两个点的链就行了。wa 了很多次。W 决定不能死在这道题上，让 Z 去做 B，让 D 去做 L。

W 画了画发现其实删边是有用的，然后根据出错的那种情况猜了一个结论。改了改之前的代码也过掉了。（还发现 D 之前写的时候没 continue）。Z 疯狂的 tle 和 wa B。W 建议推一推公式，但是 Z 还是觉得尝试一下二分和三分。

D 的 L 也写得差不多了。W 写出了 B 的公式，写了之后过掉了。后面的时间都在辅助 D，D 发现有一个小错误然后开始改，趁着最后交了几发都 wa 了。比赛结束之后再仔细看了看，发现是没有改完，改完的话就 a 了。

（W 觉得以后一定要监督 D 开数组 +10）

## coldwater

A 题后缀自动机非主流做法想不到还挺好写的，题解的转成矩形覆盖确实也很讲道理。L 一开始误判为大模拟，结果没看到数据范围，导致 D 不是很敢写。现在想来早点给他的话，应该就能过这题了。D 题读完题感受了一下觉得就是怎么暴力删边，然后 hash 判断树的同构，看过的人太少觉得可能想得太 naive 也没敢写（树同构也不怎么记得了）。B 题大力写了个式子还是比较开心的。

## ShinriiTin

越来越摸鱼了，一来接了 C 的锅，然后 A 题给了一点 idea，之后就不停带偏 J 题。然后 W 说 L 是一道大模拟让我去写，我听说是大模拟根本不想写，但是去读了一下之后发现应该是树上倍增搞一下。由于已经是比赛最后阶段，有点方，细节没有处理完，加上访问了数组的 n+1 位置却只开了 max_N+1，就背锅了。结束之后改了一下交了就 a 掉了，真的是唆不粗话。

## zhongzihao

一天到晚摸鱼，不知道在干什么，一开始就 T 了两发 C ，不知道怎么就敢写的。然后就水了一道小容斥， 1a 以后开始对着计算几何 B 绝望地 wa 和 tle 了好多好多发（最后还是 W 过的）。中间又穿插着想 G ，其实一会就想出了正解，但是莫名其妙以为是 n 方的算法到最后都没敢写。现在看来应该按照常见的 1-n 所有约数个数的 nlogn 复杂度的分析方法多想想。比赛时上界放得太宽了，或者最次打个表算算到底有多少个也好，不知道在想什么也没去打，实在是很不应该。