# Contest Info

date: 2018.08.23 12:00-17:00

[practice link](https://cn.vjudge.net/contest/248765)

# Solutions

## G. Youngling Tournament 

**题目大意**：

给出一个长度为$n\le10^5$的数列$1\le a_i\le10^{12}$，定义胜者为将$a_i$从小到大排序后的数组$b_i$中满足$(\sum_{j<i}b_j) \le b_i$的位置$i$的数量，求胜者数量。

然后$m\le50000$次单点修改，每次修改后求胜者数量。

**题解**：

胜者的数量显然不会超过$O(\log{maxA})$个，我们可以暴力去check。

用`std::multiset`维护偏序，离散化树状数组维护前缀和即可。

注意最小的数中可以出现两个胜者，其它相同的数最多只会出现一个胜者。

时间复杂度$O(n\log{n}\log{maxA})$.

## I. Equipment Assembling

**题目大意**：

给出$n\le20$个点，$m\le1000$条边的边带权无向图。

每花$1$的代价可以将一条边的边权增加或减少$1$，求最小的代价，使得最小生成森林唯一，输出方案。

**题解**：

顺着`kruskal`的过程来思考，我们将权值相同的边同时加入，先剔除掉连通性没有贡献的边，即使用权值严格更小的边就已经使两边连通了的边，之后，最小生成森林唯一的充要条件是：不存在一个环，包含两条以上当前枚举的边。

如果存在这样的环，我们有两种方式处理，一是将一些边的边权减小$1$，一是将一些边的边权增大$1$.

将连通块缩点，然后`dp`求出每个集合内部的边数$cnt[S]$，贪心地选择一个$|S|$最小的集合$S$满足：$cnt[S] - (|S|-1)>(|S|-1)$，这样集合$S$内部的边使用减小$(|S|-1)$条边的方式处理最优，优先处理掉，并使用集合内部的边更新连通性。

如果不存在这样的$S$，我们就使用增大边权的方式处理所有冲突，更新连通性，并枚举权值更大的边处理。

每次`dp`的复杂度是$O(k\times2^k)$，$k$为发生冲突的连通块数量，因为每做一次`dp`后$k$至少减少$1$，时间复杂度$O(n\cdot2^n+nm)$，实际上这个上界也远不会达到.

# Dirt Replay

B: `-1` set 找前驱的时候用 --lower_bound，如果没有前驱，lower_bound 是 begin，自减还是 begin，是个假前驱

D: `-1` Z 的高斯消元写错了

F: `-3` 读错题意；三点共线；还有一个情况

G: `-1` 没套函数

H: `-2` 启发式合并错算法；忘记 fflush（最后假算法过了）