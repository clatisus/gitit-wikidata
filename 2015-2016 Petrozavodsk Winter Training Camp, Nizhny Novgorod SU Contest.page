# Contest Info

date: 2018.08.23 12:00-17:00

[practice link](https://cn.vjudge.net/contest/248765)

# Solutions

## B. Forcefield

签到题

## C. Missing Part

**题目大意**：给你两个长度为 $n$ 的串 $s$ 和 $t$，$s$ 由 A-E 组成，$t$ 由 a-e 组成。现在你可以指定一个双射将 A-E 映射到 a-e，还可以将 $s$ 或 $t$ 循环移动。问所有的可能中失配位置最少有多少个。

**题解**：FFT 字符串匹配入门题。时间复杂度 $\mathcal{O}(5^{2}n\log n+5!n)$。

## D. Handling a Spaceship

**题目大意**：交互题。给出 $n(n\le100)$ 维空间中的一组基 $\{X_{i}\}$，以及一个 $n\times m$ 的矩阵 $K$。$K$ 满足每一行的元素严格递增，且每行至少有一个位置是 $0$。现在 $X_{i}$ 和 $K$ 都是未知的，但是每次询问你可以问一个 $n$ 维向量 $g$，交互程序会回答 $\sum_{i=1}^{n}K_{i,g_{i}}X_{i}$。在 $120$ 次询问以内，找出一个 $g$，使得 $\sum_{i=1}^{n}K_{i,g_{i}}X_{i}=\mathbf{0}$。

**题解**：因为 $\{X_{i}\}$ 是一组基，因此满足条件的 $K_{i,g_{i}}$ 必须等于 $0$，也即我们要找到 $K$ 中每一行的 $0$ 的位置。由于 $K$ 的每一行都是递增的，因此我们可以考虑 $n$ 行一起二分求解。我们可以很容易地用 $n+1$ 次询问来得到 $(K_{i,2}-K_{i,1})X_{i}$，将它们作为一组新的基。因为 $K$ 中每一行严格递增，所以 $K_{i,2}-K_{i,1}\neq 0$。

这样，每次我们询问后，都可以通过高消解出 $\sum_{i=1}^{n}K_{i,g_{i}}X_{i}$ 在这组新基下的坐标。容易发现 $\displaystyle K'_{i,g_{i}}=\frac{K_{i,g_{i}}}{K_{i,2}-K_{i,1}}$，因此 $\text{signal}(K'_{i,g_{i}})=\text{signal}(K_{i,g_{i}})$。也就是说，我们利用 $K'_{i,g_{i}}$ 的正负来进行二分效果是一样的。这样总的询问次数是 $n+1+\lceil\log n\rceil$，时间复杂度 $\mathcal{O}(n^{3}\log n)$。

## E. Cryptographic Argument

**题目大意**：一个纸带上均匀地写着 $0\sim n-1$ 的整数（其中 $n=2^{k},k\le30$）。现在将纸带对折 $k$ 次，每次将右边一半折到左边一半的下面。设对折后的纸带从上到下的数依次是 $a_{0}$ 到 $a_{n-1}$。有 $m$ 次询问，每次给出一个区间 $[l,r]$，问 $a_{l}+a_{l+1}\oplus a_{l+2}+a_{l+3}\oplus\cdots a_{r}$ 的值。若 $l$ 是偶数，那么加法优先级高；若 $l$ 是奇数，那么异或优先级高。

**题解**：容易注意到，若 $l$ 是偶数，那么 $a_{l}+a_{l+1}=a_{l}\oplus a_{l+1}=n-1$。这样一来，我们每次就只需要询问一个或两个单点的值。容易证明，若 $l$ 是偶数，那么 $a_{l}=rev(\frac{l}{2},k)$，其中 $rev(n,k)$ 表示把 $n$ 看作 $k$ 位二进制数按位翻转；若 $l$ 是奇数，那么 $a_{l}=rev(n-1-\frac{l-1}{2},k)$。实现时只需要把 $n$ 拆成两半分别翻转即可 $\mathcal{O}(1)$ 查询。

时间复杂度 $\mathcal{O}(m)$。

## G. Youngling Tournament 

**题目大意**：

给出一个长度为$n\le10^5$的数列$1\le a_i\le10^{12}$，定义胜者为将$a_i$从小到大排序后的数组$b_i$中满足$(\sum_{j<i}b_j) \le b_i$的位置$i$的数量，求胜者数量。

然后$m\le50000$次单点修改，每次修改后求胜者数量。

**题解**：

胜者的数量显然不会超过$O(\log{maxA})$个，我们可以暴力去check。

用`std::multiset`维护偏序，离散化树状数组维护前缀和即可。

注意最小的数中可以出现两个胜者，其它相同的数最多只会出现一个胜者。

时间复杂度$O(n\log{n}\log{maxA})$.

## I. Equipment Assembling

**题目大意**：

给出$n\le20$个点，$m\le1000$条边的边带权无向图。

每花$1$的代价可以将一条边的边权增加或减少$1$，求最小的代价，使得最小生成森林唯一，输出方案。

**题解**：

顺着`kruskal`的过程来思考，我们将权值相同的边同时加入，先剔除掉连通性没有贡献的边，即使用权值严格更小的边就已经使两边连通了的边，之后，最小生成森林唯一的充要条件是：不存在一个环，包含两条以上当前枚举的边。

如果存在这样的环，我们有两种方式处理，一是将一些边的边权减小$1$，一是将一些边的边权增大$1$.

将连通块缩点，然后`dp`求出每个集合内部的边数$cnt[S]$，贪心地选择一个$|S|$最小的集合$S$满足：$cnt[S] - (|S|-1)>(|S|-1)$，这样集合$S$内部的边使用减小$(|S|-1)$条边的方式处理最优，优先处理掉，并使用集合内部的边更新连通性。

如果不存在这样的$S$，我们就使用增大边权的方式处理所有冲突，更新连通性，并枚举权值更大的边处理。

每次`dp`的复杂度是$O(k\times2^k)$，$k$为发生冲突的连通块数量，因为每做一次`dp`后$k$至少减少$1$，时间复杂度$O(n\cdot2^n+nm)$，实际上这个上界也远不会达到.

# Dirt Replay

B: `-1` set 找前驱的时候用 --lower_bound，如果没有前驱，lower_bound 是 begin，自减还是 begin，是个假前驱

D: `-1` Z 的高斯消元写错了

F: `-3` 读错题意；三点共线；还有一个情况

G: `-1` 没套函数

H: `-2` 启发式合并错算法；忘记 fflush（最后假算法过了）