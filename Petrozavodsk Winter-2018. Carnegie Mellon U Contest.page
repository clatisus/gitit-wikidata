# Contest Info

date: 2019.03.10 13:15-18:15

[practice link](http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001519)

# Solutions

## A. Mines

**题目大意**：一维数轴上有 $n\le2\times10^5$ 个雷。第 $i$ 个雷在位置 $p_i$ 。花费 $c_i$ 的代价可以引爆第 $i$ 个雷，并将 $[p_i-r_i,p_i+r_i]$ 范围的雷全部引爆，引起连锁反应，而不需要额外的代价。现在有 $Q\le2\times10^5$ 次修改，每次修改一个雷的花费，然后询问使得所有雷爆炸的最小花费是多少。

**题解**：建一棵线段树，每个父亲节点向左右儿子分别连一条有向边。然后枚举每一个雷，从 $p_i$ 所在的叶子节点，向 $[p_i-r_i,p_i+r_i]$ 对应的节点连边，tarjan 求一次 scc。删掉所有可以从含有叶子节点的 scc 到达的 scc，剩下的每个包含叶子的 scc 的最小值之和就是答案。修改可以每个 scc 维护一个 multiset。时间复杂度 $\mathcal{O}(n\log{n})$ 。

## B. Balls

签到题。

## C. Flip a Coin

**题目大意**：有两个人，他们分别拥有 0/1 串 $s$ 和 $t$。现在不停地掷一枚均匀的硬币，正面为 $1$，反面为 $0$。如果某一时刻硬币组成的串中包含 $x$，那么第一个人赢；如果包含 $y$，那么第二个人赢；如果同时包含 $x,y$，那么平局。问这三种情况的概率。

**题解**：用两维分别记录 $s$ 和 $t$ 的 kmp 的 fail，高消即可。注意我们的状态的实际含义是**该状态出现次数的期望**，如果把它解释成出现的概率，个人感觉在概率论上是说不通的。由于终止状态只能出现 $0$ 或 $1$ 次，因此它出现次数的期望就是它出现的概率。 

时间复杂度 $\mathcal{O}((|s||t|)^{ 3})$。

## F. Very New York

**题目大意**：给出二维平面上的 $n\le10^5$ 个整点。给出 $q\le10^5$ 次询问，每次问到点 $(x_i,y_i)$ 的曼哈顿距离不超过 $d_i$ 的点数。

**题解**：转切比雪夫距离之后二维数点，扫描线加树状数组即可，时间复杂度 $\mathcal{O}(n\log{n})$。

## G. Sheep

**题目大意**：给你 $n$ 个 $[0,T]\to\mathbb{R}$ 上的一次函数 $f_{1},\cdots,f_{n}$，定义两个一次函数 $f,g$ 的距离为 $(\max_{x\in[0,T]}(f(x)-g(x)))^{2}+(\min_{x\in[0,T]}(f(x)-g(x)))^{2}$。要你找一个一次函数 $f$，使得 $f$ 到 $f_{1},\cdots,f_{n}$ 距离的最大值最小。

**题解**：能不能先搞清楚平方在括号里面还是外面。。。

两个一次函数相减后还是一次函数，因此最大值和最小值显然分别在 $0$ 和 $T$ 处取到。因此距离即为 $(f(0)-g(0))^{2}+(f(T)-g(T))^{2}$。设 $f_{i}(x)=kx+b$，那么我们要让 $(b_{i}-b)^{2}+((k_{i}T+b_{i})-(kT+b))^{2}$ 的最大值最小。如果我们将 $(b_{i},k_{i}T+b_{i})$ 和 $(b,kT+b)$ 分别看作平面上的点，那么显然我们就是要求 $(b_{i},k_{i}T+b_{i})$ 组成的点集的最小包围圆，而 $(b,kT+b)$ 则是最小包围圆的圆心。

时间复杂度 $\mathcal{O}(n)$。

## I. Statistics

**题目大意**：给出$n\le5000$个物品，第$i$个物品的体积为$v_i$，求所有体积和为$1\le V\le5000$且物品数量最小的集合中，最小的平均体积，最小的中位数（偶数的中位数是中间靠左的一个），最小的相同体积物品出现次数，最小的最大体积减去最小体积之差。

**题解**：先将物品按大小排序，对于同样体积的物品计算其是第几次出现。然后做若干次维护体积为$V$的最小物品数量的背包。

- 最小的平均体积就直接求出最小的物品数量即可。
- 最小的中位数，分别做前缀和后缀的背包，枚举中位数的位置，枚举中位数左边的体积和，然后检查其个数是否合法即可。
- 最小的出现次数，就枚举答案，然后每轮只把新增加的物品加入背包更新，当取到最小物品数量时停止枚举即可。
- 最小的最大体积减去最小体积之差，就`2-pointer`枚举最小体积和最大体积，用两个栈来维护删除：每次新增的加入第一个栈，并在栈顶的基础上更新背包；删除时，若第二个栈为空，则清空第一个栈，按退栈的顺序加入第二个栈，同样的更新栈顶的背包，记录每个位置的背包状态，然后删除就踢掉栈顶即可；因为只需要一个位置的值，可以$O(V)$合并两个栈顶的背包。

时间复杂度$O(nV)$.