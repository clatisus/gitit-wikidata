# Contest Info

date: 2018.10.03 12:35-17:35

[practice link](https://cn.vjudge.net/contest/258884)

# Solutions

## D. Peak Tram

**题目大意**：给定 $n\leq 70$ 个建筑物的高度 $p_i$，定义一个建筑物是可见的，当且仅当它是前缀的严格最大值。要求至少有 $k$ 个物品是可见的。改变一个建筑物高度为 $h_i$ 的代价为 $|h_i-p_i|\times c_i$，求最小代价。

**题解**：有效的高度为 $p_i\pm 70$，一共 $2n^2$ 种。dp 即可，令 $\text{dp}[i][j][k]$ 表示前 $i$ 栋建筑，可见 $j$ 栋，且最高的一座为 $k$ 高度的代价。转移的时候，枚举 $i$ 要或者不要，注意不要的时候如果它可见，那么要把它的高度改小。时间复杂度 $\mathcal{O}(n^3)$。

## F. Perfect k-ary Tree 

**题目大意**：

给出一棵$n\le 10^5$的树，问有多少个子图是完全$2\le k\le5$叉树，取模。

**题解**：

令$dp[u][j]$表示$u$为根，高度为$j$的完全$k$叉树个数，考虑点分治求解。

对于当前的分治中心，以它为根进行$dp$，转移时维护前$i$个儿子选出$k$个高度为$j-1$的完全$k$叉树的方案数即可。

当删去分治中心的时候，给它连着的所有未处理的点加一条边连向新增的点，这个点记录分治中心不适用这个子树时的$dp$信息，维护转移的前后缀即可快速求得。

新增点数不超过$n$个，并且都是叶子，不影响复杂度。

时间复杂度$O(kn\log^2{n})$.

## G. Scaffolding

**题目大意**：

要搭建$n\le10^5$列脚手架，第$i$列放$a_i$个脚手架，每次可以携带$m$个脚手架，并且只能在脚手架上左右移动或向上移动，最小化跑的次数。

**题解**：

可以考虑倒着进行，每次拆最多$m$个。

显然高的位置要优先处理，如果某次足够拆掉高的，可以在这一次顺便先拆较低的。

以原数组下标作为平衡树键值，高度作为堆键值（小根堆）建立笛卡尔树。

在笛卡尔树上自底向上贪心，令$f[u]$为将$u$子树（对应原数组的一个区间）拆到和父亲高度相同的最小次数，$g[u]$为在这个条件下可以帮较低的多拆多少个。

那么$f[u]$就包括左右儿子已经使用的次数，以及剩下要拆的数量（减去左右儿子帮忙拆的）除$m$向上取整，$g[u]$就是$f[u]\cdot m$减去实际拆掉的数量。

时间复杂度$O(n)$.

## H. Slim Cut

**题目大意**：给定一个带权无向图 $G(V,E;w)$。定义一个割是点的一个划分，把点集划分为两个非空集合 $S$ 和 $\bar{S}$。定义割 $\{S, \bar{S}\}$ 的 $\text{slimness}$ 为：

$$
\displaystyle \frac{\displaystyle \max_{(u,v)\in E, u\in S, v\in \bar{S}}w(u,v)}{\min(|S|,|\bar{S}|)}
$$

最小化 $\text{slimness}$。

**题解**：枚举最大的割边，那么大于枚举值的边形成了若干个连通块。我们希望这些连通块尽可能均匀地分在 $S,\bar{S}$ 中，做一个 0/1 背包 dp 即可。

注意到加一条边的时候，实际上是 $\text{sz}(u)$ 和 $\text{sz}(v)$ 变成了 $\text{sz}(u) + \text{sz}(v)$。也即删除和添加物品的背包 dp。我们可以维护每个物品存在的时间区间，然后对时间分治。那么现在就只有添加操作，再用 bitset 优化背包 dp 即可。

时间复杂度 $\mathcal{O}(n\log m\times \frac{n}{w})$。

## J. Taboo

**题目大意**：

给出$n$个$01$串，求一个最长的不包含这$n$个串为子串的$01$串，若无限长输出$-1$，若多解输出字典序最小的。

**题解**：

建立$Trie$图，删去不合法的状态（终止节点，以及它在trie树上的子树，以及在fail树上的子树），若不是$DAG$则可以无限长，否则正反两次求最长链，从根开始枚举字典序最小的答案即可。

# Dirt Replay

A: `-1` swap 路径写错

D: `-1` 位置 i 不作为答案时转移错误

F: `-4` 写错了一堆，共产主义复用了一个数组

J: `-1` D 坚持不用 W 的板子，写错了

K: `-1` 写错了