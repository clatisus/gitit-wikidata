# Contest Info

date 2017.08.17 12:00-17:00

[practice link](http://acm.hdu.edu.cn/search.php?field=problem&key=2017+Multi-University+Training+Contest+-+Team+8&source=1&searchmode=source)

# Solutions

## A. Army Formations

**题目大意**：给出一棵 $n\leq10^5$ 个点的二叉树，每个点有一个权值 。对于每个点 $u$，求 $ans_u = \sum\limits_{i = 1}^{sz_u}\sum\limits_{j=1}^i v_j$，也即前缀和的前缀和。其中，$\{v_j \}$ 是以 $u$ 为根的子树的所有权值升序排列的序列。

**题解**：用 splay 启发式合并自下向上计算 $ans_u$，那么就只用考虑插入一个 $a$ 对这个集合的答案的影响：会使得答案增加 $(a+\sum\limits_{x\in S\land x\leq a}x+\sum\limits_{x\in S\land x>a}a)$。然后就只用维护一下 splay 的子树和与子树大小就行了。启发式合并的时候需要简单的写一下内存回收，就中序遍历一下较小的 splay，把指针扔到一个 `vector` 里即可。

## D. Death Podracing

**题目大意**：长度为 $L$ 的环上有 $n$ 个人赛跑，每个人初始位置为 $d_i(0\leq d_i < L)$，速度为 $v_i(|v_i|\leq 10^9)$。每个人的位置互不相同，速度也互不相同。第 $i$ 个人的力量值为 $i$，当两个人相遇的时候，力量值较小的人会被淘汰。问经过多长时间最后剩下一个人。

**题解**：我们将这 $n$ 个人按照 $d_i$ 排序，用双向链表维护。显然每次相遇只可能发生在相邻的两人之间。我们用一个优先队列维护相邻两人相遇的时间（相对于时刻 $0$），每次取出一个事件，然后删除掉一个点即可。

## F. Fleet of the Eternal Throne

**题目大意**：给你 $n(n\leq 10^5)$ 个长度总和不超过 $10^5$ 的字符串 $\{s_i \}$。再给你 $m(1\leq m\leq 100)$ 次询问，每次询问 $(x,y)$，要求找到串 $s_x, s_y$ 的最长公共子串 $sub$，并且 $sub$ 是某个 $s_i$ 的前缀。输出最长长度。

**题解**：我们对每个串 $s_i$ 跑一遍 kmp 算法，求出 fail 数组。每次询问的时候，我们对 $\forall i\in [1, n]$，都求出 $f_i[x], f_i[y]$。其中，$f_i[j]$ 表示以串 $s_j$ 作为母串，$s_i$ 作为模式串，能匹配到的最长的长度。那么当前的答案即为：$\max\limits_{i=1}^n \min\{f_i[x], f_i[y]\}$。对于已经求得的 $f_i[j]$，我们用 `map` 存一下即可（其实不存复杂度差不多）。复杂度 $\mathcal{O}\left(m(|S| + \log m) \right)$。 

（题解的做法）建一个 ac 自动机，然后每次询问两个串 $s_x, s_y$，找到它们所有的前缀在自动机上的对应结点所构成的集合，分别设为 $X, Y$。答案即为： $\max\limits_{p\in X, q\in Y} dep[lca_{p, q}]$。其中，$lca$ 指的是在 fail 树上的最近公共祖先。也就是求最长的树链的交，类似虚树的构造，我们将所有点按照 dfs 序排序，然后只考虑相邻的属于不同集合的点即可。

（tls 队的做法）广义后缀自动机，然后离线。

# Replay and Summary

## Replay

W 倒着读题发现题目都好长啊，最后一道题感觉是个推推式子就能做的题，让 Z 去做，Z 说不取模抄板很麻烦待会去写。然后 Z 就开始写 B。写完 B 交了一发 wa 了，再刷新题面发现 zz 的出题人加上了取模，改了之后过了。W 也刷新了一下最后一题的题面，也加上了取模，于是就交给 Z 去做了。

Z 做完 K 交了一发 wa 掉了。W 自己也推了一个式子，上来写，也 wa 掉了。D 和 W 讨论了 A 的做法，觉得就是一个启发式合并平衡树，D 对 splay 比较熟，就接过去写。W 开始静态查 K 的错。一会儿发现忘记乘 1ll，加上之后过了。

D 写完 splay 之后直接 a 了，W 让 Z 读 H 的题意，读完之后两人交流了一下，弄清楚了限制，Z 和 W 都发现类似的题之前做过不止一次，Z 马上写了就过了。W 持续想 F 题，W 和 D 讨论了讨论什么广义后缀自动机、ac 自动机的做法，W 最后决定写一个 kmp，然后 map 记录一下。wa 了一次之后，把动态分配内存改了，然后莫名其妙就过了。

D 发现 I 题就是一个最小树形图，然后第二个限制条件的话通过编码可以实现，然后写了之后 wa 了好几次。Z 本来在做 D，写了一句话就发现算法错了。W 想了想 D 觉得直接用优先队列和链表模拟就好了，开始写。写完之后样例跑不过，就改了代码 ce 了一发，换台电脑看代码（结果 hdu 的 ce 算罚时，下降一名有点亏）。

静态查错找不到错误的 W 决定帮 D 看看 I 的代码，改了改 long long 的输入和一些很细节的东西，随便交了一发莫名其妙的过了。W 开始调试 D 题，调了一会儿找到错改了，也过了。W 和 D 开始摸鱼，Z 看了看 G 题，打了打表，发现是个逗你玩题。W 看着 Z 把这题写了，改了点小错误直接交就过了。

最后还剩一个多小时，剩的三道题中 B 没有什么想法，E 题 Z 觉得可以怎么卷积一下但是复杂度不对，W 和 D 看了 J 题觉得多半是个网络流，然后一直尝试建图，最后也没建出来。

## coldwater

## ShinriiTin

这场的题面又臭又长。一开始没有读懂 A 题是什么意思，拿样例画了一下猜到了，然后就想了一下实现的细节，很快就写完 ac 了。然后和 W 讨论了一会儿 F 和 I，我想出了 I 题，然后就开始写。写完 wa 掉了，觉得可能是我瞎改板子的问题，于是权值取负改成求最小，还是 wa。然后 W 提醒我 long long 的输入输出即使在 int 范围内也要 %I64d，否则有的 oj 会出问题，改了交，a掉了。下来之后改了一下一开始的版本，确实有瞎改板子改错的地方，但是改完之后依然不能 ac，再把 long long 的输入输出改掉，求最大树形图的方法也是可以 ac 的。以后一定要注意这个问题。之后就再没有有用的输出了，一直在摸鱼。网络流最小割的建图我们还是很不熟悉，需要加强。

## zhongzihao

zzh 擅长想出错解之后写出错误的代码然后发现想错了（不过还好这场最后都 a 掉了）。感觉这段时间写各种数学题收获还是很大， b 题是做过一万遍的莫比乌斯反演很容易就想出来了（不过出题人很坑）， h 也是 51nod 一道原题的弱化版， g 题手动打表 sg 值大概感觉到了出题人在逗比，然后说着“我不敢写啊”就 1a 了。最后 e 题想到了是个卷积，不过我写的式子没法算，还要看看题解是怎么处理的。感觉今天打的还不错。 