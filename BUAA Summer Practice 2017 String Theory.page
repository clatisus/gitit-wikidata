# Contest Info

[practice link](https://cn.vjudge.net/contest/172382)

# Solutions

## A. Password Suspects

**题目大意**：给定 $n,m$，以及 $m$ 个长度在 $10$ 以内的字符串（仅由小写字母组成）。问有多少个长度为 $n$ 的字符串，同时以这 $m$ 个字符串为子串。如果不超过 $42$ 个，那么输出方案。$1\leq n\leq 25,0\leq m\leq 10$。

**题解**：将所有的给定串插入 ac 自动机，构建一个 trie 图，在 trie 图上进行 dp。trie 图的每个节点记录一个集合 $f[p]$，表示哪些给定串是节点 $p$ 的后缀。因为给定串一定是 trie 图的前缀，所以我们插入的时候在终止节点插入元素，然后沿着 fail 链向下合并。也即 $f[p] = f[p] \cup f[fail[p]]$。 $dp[p][len][s]$ 表示从节点 $p$ 开始，当前长度为 $len$，当前包含给定串集合为 $s$ 的方案数量。从 $dp[\text{root}][0][\emptyset]$ 开始自顶向下 dp。

## C. Regular Number

**题目大意**：给定一个形如  `(0|9|7) (5|6) (2) (4|5) ` 的正则表达式。输入一个 $n(\leq 1000)$，接下来 $n$ 个 $a_i(1\leq a_i\leq 10)$ 表示每个位置的候选字符个数，以及 $a_i$ 个候选字符。输入一个长度不超过 $5\times 10^6$ 的字符串，输出所有匹配的子串。

**题解**：shift-and。

---

Algorithm Detail

算法的目的是保持一个集合 $D=\overline{d_{m-1}\dots d_0}$，表示模式串 $p$ 的哪些前缀被到目前为止的文本串后缀匹配，当 $d_{m-1}$ 有效的时候，我们得到一个匹配。

首先预处理表 $B$，对于 $p$ 的每种字符处理一个 $\overline{b_{m-1}\dots b_0}$，表示其在模式串中的出现位置。例如 `announce` 中，字符 `n` 的表 `00100110`。表示位置 $1,2,5$ 有字符 `n`。表中还需要添加一个空集 $\emptyset$ ，表示匹配失败。

初始化 $D=0$ ，依次扫描文本串，更新状态为 `D <- ((D << 1) | 1) & B[current-char]`。先左 shift 一位，表示不考虑当前字符匹配的集合 $D$，因为空集 $\emptyset$ 一定匹配成功，所以我们还要或上一个 $1$，接着 and 上当前字符的出现位置。

## G. Palindromic Border 

**题目大意**：定义一个串的 Palindromic Border 如下：

- 它是回文的
- 它既是原串的前缀，也是原串的后缀

求给定串的所有子串（只要起始的位置不同就认为是不同的子串）的 Palindromic Border 的个数之和。

**题解**：建出原串的回文树，搞出所有本质不同的回文子串和其出现次数，则每种回文子串的贡献就是$\displaystyle \binom{k}{2}$，$k$ 是该子串在原串中出现的次数。

## H. Yong Zheng's Death 

**题目大意**：给出一个字符串集合 $S = \{ s_1, s_2, \dots, s_n \}$，$|s_i| \leq 30,n\leq 10^4$ 。从 $S$ 中任取两个串的前缀拼成一个字符串，问共有多少个本质不同的串。

**题解**：对 $S$ 建一个 ac 自动机，得到 $S$ 中本质不同的前缀共有 $cnt$ 个，则答案为 $cnt^2$ 减去重复的情况。

考虑如何计算重复的情况，对于最终得到的一个串 $C = A_1 + B_1 = A_2 + B_2 = \cdots = A_k +B_k$ ，$A_i$ 和 $B_i$ 的拼接线为 $l_i$，我们规定 $l_i$ 最靠近 $C$ 的开头位置的方案是合法的，其它的都是不合法的（重复方案）。 

我们枚举这个拼接线，也即枚举前缀 $B$ ，然后减去恰在当前拼接线右侧的那个拼接线的情况。那么它所对应的前缀 $B^{'}$ 是 $S$ 中的一个前缀，且是 $B$ 的最长的后缀。显然，这就是 $B$ 在 ac 自动机的 $fail$ 指针指向的位置。之后就要考虑有多少种不同的非空前缀 $A$ 和 $A^{'}$ 能满足 $A + B = A^{'} +B^{'}$。

稍微画图可以发现，$A^{'} = A + X$，$B = X + B^{'}$，其中 $X$ 为 $B$ 的一个前缀。我们要求的是 $A^{'}$ 的数量，就等于 $S$ 中以 $X$ 作为后缀的前缀的数量，直接在 $AC$ 自动机中询问 $X$ 串在 $fail$ 树中的子树大小即可（记得减去 $A^{'} = X$ 的情况， $A$ 不能为空）。因为串的长度不超过 $30$ ，我们可以直接在 ac 自动机中由 $B$ 向上走就可以找到 $X$。

##  L. The Problem to Slow Down You

**题目大意**：给出两个只有小写字母的字符串，求这两个串有多少对公共子串是回文的。

**题解**：对两个串分别建回文树，然后在两棵树上从根 0 和根 1 各进行一次 dfs。每个位置的贡献就是 A.cnt[x] * B.cnt[y]。