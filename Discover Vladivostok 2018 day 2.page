# Solution

## A. King's Tree

**题目大意**：

给出一棵$n$个节点的树，每条边上有一个整数$1\le v_i<10^6+3$，求一条路径$(u,v)$，满足路径上所有边的乘积$\mod{10^6+3}$为$K$，当有多条满足的路径时，输出$(u,v)$字典序最小的一个。

**题解**：

点分治维护到每个重心的所有路径，有相同乘积时保留端点字典序最小的一个，$O(n\log{n})$.

## B. LWDB

**题目大意**：

有一棵$n$个节点的树，每个点初始颜色为$0$。

之后$m$次操作，每次操作为以下两种之一：

- 将到点$v$距离不超过$d$的点都染色为$c$
- 询问点$v$的颜色

**题解**：

先建出点分树，然后在每个重心处维护一个单调栈。

对于每次修改操作，从$v$开始修改$\log{n}$个重心，将单调栈中之前的影响范围减去到重心距离比$v$小的修改都弹掉。

对于每次询问操作，从$v$开始修改$\log{n}$个重心，在单调栈中二分找到会影响$v$的修改，再将修改时间取$max$即可。

时间复杂度$O(n\log^2{n})$，空间复杂度$O(n\log{n})$.

C. Decomposition

输出点分树即可。


## H. Tree Problem 

**题目大意**：

给出一棵$n$个节点的树，每条边一开始都是黑边。

之后$m$次操作，每次操作为以下两种之一：

- 统计路径$u$到$v$中黑边的数量
- 将所有两个点在路径$u$到$v$中的边变成白色，将有且仅有一个点在路径中的边变成黑色

**题解**：

先轻重链剖分，然后用两棵线段树分别维护轻重边。

对于重边：

- 在修改时，对于路径中的重边，在相应的线段树上进行区间修改使其变为白色，对于路径边缘的重边，在线段树上进行单点修改使其变为黑色。
- 在询问时，直接在相应的线段树上进行区间查询求得路径中的黑色重边数量。

对于轻边：

- 维护每个点被操作二影响的最晚时间`opt[x]`，以及每条轻边被变成黑色的最晚时间`last[x]`，那么每条轻边当前是黑色的充要条件就是$last[x] \ge opt[p[x]]$.
- 用线段树维护`opt[x]`，则每次修改时只需要对路径中的点进行区间修改即可。
- 修改时只需要对$\log{n}$条轻边进行`last`修改，查询时在线段树中查询也是$\log{n}$次

时间复杂度$O(n\log^2{n})$.