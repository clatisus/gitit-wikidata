# Contest Info

date: 2018.10.07 12:40-17:40

[practice link](https://cn.vjudge.net/contest/259539)

# Solutions

## B. Fraction

签到题。

## D. Triangle

签到题

## E. The Fastest Runner Ms. Zhang

**题目大意**：

给出一个$n\le10^5$个点$n$条边，每条边边权为$1$的简单无向连通图，选两个点$S$和$T$，从$S$出发经过每个点至少一次并停在$T$，最小化路径长度，相同时最小化有序对$(S,T)$的字典序。

**题解**：

先建出基环外向树，设环上有$x$个点，分$S$和$T$所在子树在环上的根，记为$rt(S)$和$rt(T)$，是否相同两种情况讨论：

- 相同，则$S$到$T$的链上边只会经过一次，其它树边经过$2$次，环上的边都经过一次，路径长度为$2n-x-dis(S,T)$.
- 不同，则$S$和$T$分别到$rt(S)$和$rt(T)$的链上的边只会经过一次，其它树边经过$2$次，环上会从$rt(S)$走一圈到达离$rt(T)$较近的一个$rt(S)$的邻点，再走到$rt(T)$，路径长度为$2n-dis(S,rt(S))-dis(T,rt(T))-x-dis(rt(S),rt(T))-2$.

树`dp`求出每棵子树最长链和到根最长链即可，环上的部分单调队列优化一下，时间复杂度$O(n)$.

## F. Harmonic Value Description

签到题。

## K. Binary Indexed Tree 

**题目大意**：定义树状数组的实现方式如下：

```c++
void add (int x, int t){
    for (int i = x; i != 0; i -= i & (-i))
        a[i] += t;
}
```

修改区间 $[l,r]$ 时调用 `add(r, 1)` 及 `add(l-1, -1)`。定义区间 $[l,r]$ 的价值为修改它时真正改变了的位置，即修改 $r$ 和修改 $l-1$ 时抵消的位置不算。求所有 $[1,n]$ 的子区间的价值和。

**题解**：修改 $[l,r]$ 时，真正改变的位置即为 $\text{bitcount}(r)+\text{bitcount}(l-1)-2\text{bitcount}(x)$，其中 $x$ 是 $l-1$ 和 $r$ 的最长公共前缀。

我们分两个部分计算该答案。显然减号前面的答案为 $n\sum_{i=0}^{n}\text{bitcount}(i)$。减号后面的答案只需要枚举 $l$ 和 $r$ 的最长公共前缀的长度，然后数位 $dp$ 即可。

# Dirt Replay

F: `-1` 写反了（没自己测试）

G: `-1` 写错了（自己没法测试）