# Contest Info

date: 2019.03.01 18:03-23:03

[practice link](http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001533)

# Solutions

## A. Digits Are Not Just Characters

签到题。


## B. Arithmetic Progressions

**题目大意**：给你一个长度为 $n$ 且互不相同的数列，要求你用这些数组成一个等差数列（顺序可以交换），且长度尽可能大。

**题解**：排序后对每个位置维护每种公差对应的最大长度即可。

都 `9102` 年了，出题人会卡 `unordered_map` 了，还是尽可能想一点更好的实现方法。

时间复杂度 $\mathcal{O}(n^{2})$。

## C. Emergency Evacuation

**题目大意**：有一辆车，总共 $r$ 排，有一条过道，两边分别有 $s$ 个座位。现在某些位置上有人，他们要下车，每一步，不靠过道的座位上的人可以向过道移动一个位置；靠过道的座位上的人可以移动到该排的过道；某排过道上的人可以移动到下一排的过道；靠出口那一排过道上的人可以出去。移动的前提是该位置上没有人，或者这个人也要移动；如果多个人可以移动到同一个位置，只能有一个人移动。问最快多少步所有人能下车。

**题解**：贪心即可，只要我能移动就移动。唯一出现多个人可以移动到同一个位置的情况就是两边靠过道的位置都有人，这时谁走到过道都是一样的。

实现时用 `bitset` 维护每一行过道是否空闲的信息。

时间复杂度 $\displaystyle{\mathcal{O}(\frac{r^{2}s}{64})}$。

## D. Shortest Common Non-Subsequence

**题目大意**：给出两个 `01` 串 $s_1$ 和 $s_2$ ，求长度最短，多个时字典序最小，的 `01` 串 $t$ ， $t$ 既不是 $s_1$ 的子序列，也不是 $s_2$ 的子序列，$1\le|s_1|,|s_2|\le4000$。

**题解**：假如已知串 $t$ ，贪心判断其是否为串 $s$ 的子序列的方法是，从第一个位置开始，每一次选当前位置最近的一个可以与 $t$ 匹配的位置匹配，如果这样都无法匹配，则 $t$ 不是 $s$ 的子序列。假设字符串下标从 $1$ 开始，令 `dp[i][j]` 表示在两个串分别从（含） $i$ 和 $j$ 开始匹配时的最小长度，令 $n+1$ 和 $m+1$ 为失配位置，则 `dp[n+1][m+1] = 0` ， `dp[0][0]` 是答案。我们从后往前求出 dp 值，然后从状态 $\{0,0\}$ 开始贪心枚举转移，得到字典序最小的答案。时间复杂度 $\mathcal{O}(nm)$。

## G. What Goes Up Must Come Down

**题目大意**：给定一个长度为 $n$ 的数列，一次操作为交换两个相邻的数。问最少操作多少次，使得存在一个位置 $k$（$1\le k\le n$），满足 $a_1,\dots,a_k$ 单调不降，$a_k,\dots,a_n$ 单调不增。

**题解**：把所有数字从小到大排序。然后依次考虑，每次把它往左放，或者往右放。往左放的代价，是原位置左边还未放的数字个数，用 Fenwick Tree 维护一下；往右放同理。

实现的时候，每次考虑同一种数字，比较最左一个位置往左放的代价，和最右一个位置往右放的代价。

## J. Colorful Tree

**题目大意**：给出一棵树，每个点有个颜色。若干次操作，或者修改一个点的颜色，或者询问一种颜色的点的虚树周长。

**题解**：直接每种颜色用一个 `set` 维护 `dfs` 序，虚树周长就等于相邻两个点的距离和（加首尾）的一半。时间复杂度 $\mathcal{O}(n\log{n})$ 。

## K. Sixth Sense

**题目大意**：给出两个长度为 $n$ 的序列 $a_1,\dots, a_n$ 和 $b_1,\dots, b_n$。要求你把序列 $b$ 重新排列，使得 $\sum_{i=1}^n [a_i<b_i]$ 最大，其次 $b$ 字典序最大。

**题解**：先考虑如何求最大的 sum。我们把两个序列分别排序，然后用 two point 维护，对于每个 $a_i$，贪心的选择最小的比它大的 $b_j$。

然后我们考虑让字典序最大，同时保持最大的 sum 可以取到。我们按照输入顺序，依次枚举 $a_i$。在排序之后的 $b'$ 中找到恰比它大的位置 $j$，设现在 $b'$ 的长度为 $m$。那么我们可以在区间 $[j, m]$ 中二分，使得 $a_i$ 和这个数配对，产生 $1$ 的贡献之后，剩下的数字仍能达到最大的 sum。

否则，我们在区间 $[1, j)$ 中同样二分，但是此时不产生贡献。注意从 $b'$ 中删掉最后二分出的数字，同时在 $a'$ 中给 $a_i$ 打上删除标记。

复杂度 $\mathcal{O}(n^2\log n)$。
