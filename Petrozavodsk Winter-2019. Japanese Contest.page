# Contest Info

date: 2019.03.01 18:03-23:03

[practice link](http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001533)

# Solutions

## A. Digits Are Not Just Characters

签到题。


## B. Arithmetic Progressions

**题目大意**：给你一个长度为 $n$ 且互不相同的数列，要求你用这些数组成一个等差数列（顺序可以交换），且长度尽可能大。

**题解**：排序后对每个位置维护每种公差对应的最大长度即可。

都 `9102` 年了，出题人会卡 `unordered_map` 了，还是尽可能想一点更好的实现方法。

时间复杂度 $\mathcal{O}(n^{2})$。

## C. Emergency Evacuation

**题目大意**：有一辆车，总共 $r$ 排，有一条过道，两边分别有 $s$ 个座位。现在某些位置上有人，他们要下车，每一步，不靠过道的座位上的人可以向过道移动一个位置；靠过道的座位上的人可以移动到该排的过道；某排过道上的人可以移动到下一排的过道；靠出口那一排过道上的人可以出去。移动的前提是该位置上没有人，或者这个人也要移动；如果多个人可以移动到同一个位置，只能有一个人移动。问最快多少步所有人能下车。

**题解**：贪心即可，只要我能移动就移动。唯一出现多个人可以移动到同一个位置的情况就是两边靠过道的位置都有人，这时谁走到过道都是一样的。

实现时用 `bitset` 维护每一行过道是否空闲的信息。

时间复杂度 $\displaystyle{\mathcal{O}(\frac{r^{2}s}{64})}$。

## D. Shortest Common Non-Subsequence

**题目大意**：给出两个`01`串$s_1$和$s_2$，求长度最短，多个时字典序最小，的`01`串$t$，$t$既不是$s_1$的子序列，也不是$s_2$的子序列，$1\le|s_1|,|s_2|\le4000$。

**题解**：假如已知串$t$，贪心判断其是否为串$s$的子序列的方法是，从第一个位置开始，每一次选当前位置最近的一个可以与$t$匹配的位置匹配，如果这样都无法匹配，则$t$不是$s$的子序列。令`dp[i][j]`表示在两个串的匹配位置分别为$i$和$j$时的最小长度，分别令$n+1$和$m+1$为失配位置，则`dp[0][0] = 1`，`dp[n+1][m+1]`是答案。将这个`dp`反过来，就可以从前往后枚举答案串的每一位，得到字典序最小的答案。时间复杂度$O(nm)$.

## G. What Goes Up Must Come Down

**题目大意**：给定一个长度为 $n$ 的数列，一次操作为交换两个相邻的数。问最少操作多少次，使得存在一个位置 $k$（$1\le k\le n$），满足 $a_1,\dots,a_k$ 单调不降，$a_k,\dots,a_n$ 单调不增。

**题解**：把所有数字从小到大排序。然后依次考虑，每次把它往左放，或者往右放。往左放的代价，是原位置左边还未放的数字个数，用 Fenwick Tree 维护一样；往右放同理。

实现的时候，每次考虑同一种数字，比较最左一个位置往左放的代价，和最右一个位置往右放的代价。

