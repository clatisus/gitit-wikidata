# Contest Info

date: 2018.08.29 13:30-18:30

practice link: opentrains 10397

# Solutions

## F. Monsters

**题目大意**：给定两个长度为 $n$ 的正整数数列 $\{M_i\},\{S_i\}$，定义当前的价值为 $\displaystyle \prod_{i=1}^n \min\left(M_i, \max_{j=1}^iS_j\right)$。还有 $k$ 次修改，每次把两个数列中的某个数字变大，让你每次输出修改之后的价值。

**题解**：

## G. Regular expressions

**题目大意**：定义正则表达式如下：

- `a,g,t,c` 字符集

- `(R|P)`

- `(RP)`

- `(R*)`

其中 `*` 表示可以出现 $0$ 次或若干次，给出一个字符串集合，输出能匹配这个集合的最短的正则表达式。

**题解**：显然 `((((a|g)|t)|c)*)` 一定是一个答案，其长度为 $16$。我们只需要暴力生成长度小于等于 $15$ 的正则表达式，然后每次暴力判断即可。我们先枚举不含 `*` 和 `|` 的基本串，并且显然这些串中不能有连续的相等子串，例如 `agaga` 可以写成 `(a((ga)*))` ，优于 `((((ag)a)g)a)`。然后我们在基本串上应用规则生成其他串即可，几个剪枝：1.基本串不直接拼接。2.我们用 `|` 连接两个串的时候，要求前半的长度大于后半。3.不拼接 `(u*)` 和 `u`，也不在 `(u*)` 的外面套一层 `*`。

最后，我们可以搜出 $50403$ 个串。c++ 的 std::regex 很慢，所以我们用 java 的 Pattern 类，预处理之后直接暴力即可，可以通过本题。

## H. WSO-2017 soccer team

## I. Primitive divisors

## J. Tickets

签到题。

## K. Logarithm smoothing

## L. Outer space signals

签到题。

# Dirt Replay

A: `-2` D 弱智

B: `-4` 没有还原位置，没有还原方向，f 和 c 个数关系判断错

D: `-3` 输出方案写错

E: `-2` 算法细节

J: `-1` 交成了 hello world（数字题号有毒）

K: `-3` 式子写错两次，eps 开大了

L: `-1` 没有判串不存在