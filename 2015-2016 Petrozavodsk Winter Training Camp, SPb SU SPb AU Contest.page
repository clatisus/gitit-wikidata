# Contest Info

date: 2017.10.09 15:50-20:50

[practice link](http://codeforces.com/gym/100956/)

# Solutions

## A. Random Points on the Circle

**题目大意**：在一个圆上有 $n$ 个点，每个点的坐标在 $[0,L)$ 之间（ $L$ 是圆的周长），定义两个点之间的距离为 $\min(|a-b|,L-|a-b|)$ 。现在要在圆上建 $k$ 个收集器，每个点必须被分配到且只分配到一个收集器，定义一个收集器的花费为分配给它的所有点到它的距离之和，求所有收集器中最大的花费的最小值。

**题解**：显然二分答案，考虑如何验证。先对所有点进行排序，并且把它们向右扩展一倍。容易知道，要达到最优值，分配给每个收集器的一定是一个区间。而每个点都要被分配到一个收集器，所以这些区间实际上形成了一个划分。对于一个区间，最优的设立收集器的位置显然是这个区间的中位数，通过预处理前缀和我们可以 $\mathcal{O}(1)$ 知道每个区间的花费。

之后我们可以通过 two pointers 的方法，求得从每一个点开始，通过不超过当前二分的花费，能到达的最右的位置 $r_i$ 。再枚举 $[1,r_1]$中的每个点作为开始，贪心（每次走最远）判断一下是否能在 $k$ 个收集器以内处理完所有点。如果答案为从 $[1,r_1]$ 之外的点开始，那么最后一定在 $[1,r_1]$ 中结束，否则开始和结束的点区间花费不满足要求，所以我们只需要枚举一个区间即可。时间复杂度不好证明，虽然看起来每次验证是 $r_i\times k$ ，但是实际上这个复杂度没法达到。

tips：参考了一些别人的代码发现了一个优化，我们不在 $[1,r_1]$ 中验证，而是去找到使得 $r_i-i$ 最小的 $i$ 。然后枚举 $[i, r_i]$ 中的点进行验证，这样每次我们至少跳 $r_i-i$ 的距离，复杂度为 $\mathcal{O}((r_i-i)\cdot \frac{n}{r_i-i})=\mathcal{O}(n)$ 。最后总复杂度为 $\mathcal{O}(n\log n)$ 。

## H. Points

**题目大意**： 给你 $n$ 个三维空间中的向量，要求从中选取 $k$ 个，让这些向量的和的模最大。

**题解**：标程是 $\mathcal{O}(n^{5})$ 的确定算法，不太明白它的正确性。还有一种随机算法，每次对所有向量 random_shuffle 一下，然后先将前 $k$ 个作为当前选取的向量，枚举所有的 $(i,j)$ 对，如果 $i$ 已经选取，而 $j$ 未被选取，就看看去掉 $i$ ，加上 $j$ 能否让答案更优，如果更优就做这一改变。枚举完后再记录一下当前的最优值，并从头反复执行这一算法。
