```c++
// 中国剩余定理模板
// 求方程组 x = remain1(mod moder1), x = remain2(mod moder2) 的解
// p.crt(q) 返回方程 p, q 的解 

#include<bits/stdc++.h>
#include "euclidinv.cpp"

typedef long long ll;

// 如果没有 __int128 就只能这么写啦 
ll multmod(ll a, ll b, ll moder){
	return (a * b - (ll)((long double) a * b / moder) * moder) % moder;
}

template <typename T> 
class modequa{
private:
	T remain, moder;
	
	ll getone(int n){return 1;}
	__int128 getone(ll n){return 1;}
	
public:
	modequa <T>(){}
	modequa <T>(T remain, T moder) : remain(remain), moder(moder){}
	T getremain(){return remain;}
	T getmoder(){return moder;}
	
	modequa <T> crt(const modequa <T> &p){
		auto one = getone(remain);
		T x, y;
		T gcd = ex_euc(moder, p.moder, x, y);
		if ((p.remain - remain) % gcd) return modequa <T>(0, 0);
		T lcm = moder / gcd * p.moder;
		T ans = (p.remain - remain) / gcd;
		ans = one * ans * x % lcm * moder % lcm;
		ans += remain;
		ans += ans < 0 ? lcm : ans >= lcm ? -lcm : 0;
		return modequa <T>(ans, lcm);
	}
};
```