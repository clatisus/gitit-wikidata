# [Codecraft-18 and Codeforces Round #458 (Div. 1 + Div. 2, combined)](http://codeforces.com/contest/914)

## [A. Perfect Squares](http://codeforces.com/contest/914/problem/A)

签到题，求输入的数中不是平方数的最大的数是多少。**居然因为打漏了一个等号fst了!**

## [B. Conan and Agasa play a Card Game](http://codeforces.com/contest/914/problem/B)

**题目大意：**

Conan和Agasa玩游戏，有$n$种卡片，第$i$种卡片有$a_i$张，两人轮流操作，每次操作选择一张剩下的卡片，将它和所有数量比它少的种类的卡片都删掉，无法进行操作的人输。Conan先手，问双方都采取最优策略的情况下谁会获胜。

**题解：**

显然只要有一种卡片的数量是奇数，就是先手赢，否则后手赢。

## [C. Travelling Salesman and Special Numbers](http://codeforces.com/contest/914/problem/C)

**题目大意：**

定义$f(x)$为$x$二进制下$1$的个数，$g(x)$为$x$最少经过多少次$f$变换后会变成$1$。求不大于$1\le n<2^{1000}$的$0\le g(x)=k\le1000$的数的个数，对$10^9+7$取模。

**题解：**

因为$n<2^{1000}$，所以会对答案作贡献的数，经过一次$f$变换后一定不大于$1000$，因此可以预处理出$1000$以内的数的$g(x)$，然后枚举$g(x)=k-1$，去统计不大于$n$的二进制下有$x$个$1$的数的个数即可。

**注意特判$k=1$时，一定会多算一个$1$的贡献。**

```c++
#include <bits/stdc++.h>

const int max_N = 1e3 + 21;

const int mod = 1e9 + 7;

char s[max_N];

int sum[max_N];

int n,k,C[max_N][max_N];

int f[max_N],cnt[max_N];

inline int calc(int k){
	int res=0;
	for(int i=0;i<n;++i){
		if(i&&sum[i-1]>k)continue;
		if(s[i]!='1')continue;
		if(n-i-1<k-(i?sum[i-1]:0))continue;
		res=(res+C[n-i-1][k-(i?sum[i-1]:0)])%mod;
	}
	if(k==sum[n-1])(++res)%=mod;
	return res;
}

int main(){
	C[0][0]=1;
	for(int i=1;i<=1000;++i){
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;++j){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		}
	}
	for(int i=1;i<=1000;++i){
		cnt[i]=cnt[i-(i&-i)]+1;
	}
	for(int i=2;i<=1000;++i){
		f[i]=f[cnt[i]]+1;
	}
	scanf("%s%d",s,&k);
	n=strlen(s);
	if(n==1&&s[0]=='1'&&k==1){
		puts("0");
		return 0;
	}
	for(int i=0;i<n;++i){
		sum[i]=(s[i]=='1');
		if(i)sum[i]+=sum[i-1];
	}
	int ans=0;
	for(int i=1;i<=1000;++i)
		if(f[i]==k-1){
			ans=(ans+calc(i))%mod;
		}
	if(!k)ans=1;
	else if(k==1)ans=(ans-1+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```

## [D. Bash and a Tough Math Puzzle](http://codeforces.com/contest/914/problem/D)

**题目大意：**

有一个长度为$n\le5\times10^5$的数组$a$，接下来$q\le4\times10^5$次操作，每次操作是以下两种之一：

- 询问区间 $[l,r]$ 是否可以最多只改变一个位置的数，使得区间的$gcd$等于$x$；

- 将位置$i$的数修改为$y$；

**题解：**

用线段树维护区间$gcd$，询问时二分找到最小的$i$，使得$[l,i]$的$gcd$不被$x$整除，然后尝试修改$a_i$，查询$[i+1,r]$区间的$gcd$，判断其是否能被$x$整除即可。修改则直接修改。

在线段树上二分，复杂度$O(n\log{n})$乘上求$gcd$的复杂度。

```c++
#include <bits/stdc++.h>

template<typename T>inline void read(T&x){
	register char c; while(!isdigit(c=getchar()));
	for(x=c-48;isdigit(c=getchar());x=x*10+c-48);
}

const int max_N = 5e5 + 21;

int n,q,a[max_N],type,ans;

int seg[max_N<<2],pos[max_N];

#define ls(x) ((x)<<1)
#define rs(x) (ls(x)|1)
#define mid ((l+r)>>1)
#define lch ls(x),l,mid
#define rch rs(x),mid+1,r

inline void update(int x){
	seg[x]=std::__gcd(seg[ls(x)],seg[rs(x)]);
}

void build(int x,int l,int r){
	if(l==r){
		seg[x]=a[l];
		pos[l]=x;
		return;
	}
	build(lch),build(rch);
	update(x);
}

void modify(int x,int y){
	seg[pos[x]]=y;
	for(int i=pos[x]>>1;i;i>>=1)update(i);
}

int ql,qr,qx,qa,qk;

void query(int x,int l,int r){
	if(ql<=l&&r<=qr){
		qx=std::__gcd(qx,seg[x]);
		return;
	}
	if(ql<=mid)query(lch);
	if(qr>mid) query(rch);
}

void biS(int x,int l,int r){
	if(ql<=l&&r<=qr){
		if(l==r){
			qx=std::__gcd(qx,seg[x]);
			if(qa==-1&&(qx%qk)!=0)qa=l;
			return;
		}
		int tmp=std::__gcd(qx,seg[ls(x)]);
		if(!(tmp%qk))qx=tmp,biS(rch);
		else biS(lch);
	}
	else{
		if(ql<=mid)biS(lch);
		if(qr>mid) biS(rch);
	}
}

int main(){
	read(n);
	for(int i=1;i<=n;++i)read(a[i]);
	build(1,1,n);
	read(q);
	while(q--){
		read(type);
		if(type==1){
			read(ql),read(qr),read(qk);
			qx=0,qa=-1;
			biS(1,1,n);
			if(qa==-1)ans=1;
			else if(ql==qr||qa==qr)ans=1;
			else{
				ql=qa+1,qx=0;
				query(1,1,n);
				ans=!(qx%qk);
			}
			puts(ans?"YES":"NO");
		}
		else{
			int x,y;
			read(x),read(y);
			modify(x,y);
		}
	}
	return 0;
}
```

## [E. Palindromes in a Tree](http://codeforces.com/contest/914/problem/E)

**题目大意：**

给出一棵$n\le2\times10^5$的树，每个节点都有且只有一个字符(小写字母$a-t$)。对每一个节点，询问有多少条经过它的路径（交换起点终点算同一条路径）组成的字符串是回文的。


