## [A. Perfect Squares](http://codeforces.com/contest/914/problem/A)

签到题，求输入的数中不是平方数的最大的数是多少。**居然因为打漏了一个等号fst了!**

## [B. Conan and Agasa play a Card Game](http://codeforces.com/contest/914/problem/B)

**题目大意：**

Conan和Agasa玩游戏，有$n$种卡片，第$i$种卡片有$a_i$张，两人轮流操作，每次操作选择一张剩下的卡片，将它和所有数量比它少的种类的卡片都删掉，无法进行操作的人输。Conan先手，问双方都采取最优策略的情况下谁会获胜。

**题解：**

显然只要有一种卡片的数量是奇数，就是先手赢，否则后手赢。

## [C. Travelling Salesman and Special Numbers](http://codeforces.com/contest/914/problem/C)

**题目大意：**

定义$f(x)$为$x$二进制下$1$的个数，$g(x)$为$x$最少经过多少次$f$变换后会变成$1$。求不大于$1\le n<2^{1000}$的$0\le g(x)=k\le1000$的数的个数，对$10^9+7$取模。

**题解：**

因为$n<2^{1000}$，所以会对答案作贡献的数，经过一次$f$变换后一定不大于$1000$，因此可以预处理出$1000$以内的数的$g(x)$，然后枚举$g(x)=k-1$，去统计不大于$n$的二进制下有$x$个$1$的数的个数即可。

**注意特判$k=1$时，一定会多算一个$1$的贡献。**

```c++
#include <bits/stdc++.h>

const int max_N = 1e3 + 21;

const int mod = 1e9 + 7;

char s[max_N];

int sum[max_N];

int n,k,C[max_N][max_N];

int f[max_N],cnt[max_N];

inline int calc(int k){
	int res=0;
	for(int i=0;i<n;++i){
		if(i&&sum[i-1]>k)continue;
		if(s[i]!='1')continue;
		if(n-i-1<k-(i?sum[i-1]:0))continue;
		res=(res+C[n-i-1][k-(i?sum[i-1]:0)])%mod;
	}
	if(k==sum[n-1])(++res)%=mod;
	return res;
}

int main(){
	C[0][0]=1;
	for(int i=1;i<=1000;++i){
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;++j){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		}
	}
	for(int i=1;i<=1000;++i){
		cnt[i]=cnt[i-(i&-i)]+1;
	}
	for(int i=2;i<=1000;++i){
		f[i]=f[cnt[i]]+1;
	}
	scanf("%s%d",s,&k);
	n=strlen(s);
	if(n==1&&s[0]=='1'&&k==1){
		puts("0");
		return 0;
	}
	for(int i=0;i<n;++i){
		sum[i]=(s[i]=='1');
		if(i)sum[i]+=sum[i-1];
	}
	int ans=0;
	for(int i=1;i<=1000;++i)
		if(f[i]==k-1){
			ans=(ans+calc(i))%mod;
		}
	if(!k)ans=1;
	else if(k==1)ans=(ans-1+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```

## [D. Bash and a Tough Math Puzzle](http://codeforces.com/contest/914/problem/D)

**题目大意：**



