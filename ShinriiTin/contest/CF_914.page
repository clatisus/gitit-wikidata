# [Codecraft-18 and Codeforces Round #458 (Div. 1 + Div. 2, combined)](http://codeforces.com/contest/914)

## [A. Perfect Squares](http://codeforces.com/contest/914/problem/A)

签到题，求输入的数中不是平方数的最大的数是多少。**居然因为打漏了一个等号fst了!**

## [B. Conan and Agasa play a Card Game](http://codeforces.com/contest/914/problem/B)

**题目大意：**

Conan和Agasa玩游戏，有$n$种卡片，第$i$种卡片有$a_i$张，两人轮流操作，每次操作选择一张剩下的卡片，将它和所有数量比它少的种类的卡片都删掉，无法进行操作的人输。Conan先手，问双方都采取最优策略的情况下谁会获胜。

**题解：**

显然只要有一种卡片的数量是奇数，就是先手赢，否则后手赢。

## [C. Travelling Salesman and Special Numbers](http://codeforces.com/contest/914/problem/C)

**题目大意：**

定义$f(x)$为$x$二进制下$1$的个数，$g(x)$为$x$最少经过多少次$f$变换后会变成$1$。求不大于$1\le n<2^{1000}$的$0\le g(x)=k\le1000$的数的个数，对$10^9+7$取模。

**题解：**

因为$n<2^{1000}$，所以会对答案作贡献的数，经过一次$f$变换后一定不大于$1000$，因此可以预处理出$1000$以内的数的$g(x)$，然后枚举$g(x)=k-1$，去统计不大于$n$的二进制下有$x$个$1$的数的个数即可。

**注意特判$k=1$时，一定会多算一个$1$的贡献。**

```c++
#include <bits/stdc++.h>

const int max_N = 1e3 + 21;

const int mod = 1e9 + 7;

char s[max_N];

int sum[max_N];

int n,k,C[max_N][max_N];

int f[max_N],cnt[max_N];

inline int calc(int k){
	int res=0;
	for(int i=0;i<n;++i){
		if(i&&sum[i-1]>k)continue;
		if(s[i]!='1')continue;
		if(n-i-1<k-(i?sum[i-1]:0))continue;
		res=(res+C[n-i-1][k-(i?sum[i-1]:0)])%mod;
	}
	if(k==sum[n-1])(++res)%=mod;
	return res;
}

int main(){
	C[0][0]=1;
	for(int i=1;i<=1000;++i){
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;++j){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		}
	}
	for(int i=1;i<=1000;++i){
		cnt[i]=cnt[i-(i&-i)]+1;
	}
	for(int i=2;i<=1000;++i){
		f[i]=f[cnt[i]]+1;
	}
	scanf("%s%d",s,&k);
	n=strlen(s);
	if(n==1&&s[0]=='1'&&k==1){
		puts("0");
		return 0;
	}
	for(int i=0;i<n;++i){
		sum[i]=(s[i]=='1');
		if(i)sum[i]+=sum[i-1];
	}
	int ans=0;
	for(int i=1;i<=1000;++i)
		if(f[i]==k-1){
			ans=(ans+calc(i))%mod;
		}
	if(!k)ans=1;
	else if(k==1)ans=(ans-1+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```

## [D. Bash and a Tough Math Puzzle](http://codeforces.com/contest/914/problem/D)

**题目大意：**

有一个长度为$n\le5\times10^5$的数组$a$，接下来$q\le4\times10^5$次操作，每次操作是以下两种之一：

- 询问区间 $[l,r]$ 是否可以最多只改变一个位置的数，使得区间的$gcd$等于$x$；

- 将位置$i$的数修改为$y$；

**题解：**

用线段树维护区间$gcd$，询问时二分找到最小的$i$，使得$[l,i]$的$gcd$不被$x$整除，然后尝试修改$a_i$，查询$[i+1,r]$区间的$gcd$，判断其是否能被$x$整除即可。修改则直接修改。

在线段树上二分，复杂度$O(n\log{n})$乘上求$gcd$的复杂度。

```c++
#include <bits/stdc++.h>

template<typename T>inline void read(T&x){
	register char c; while(!isdigit(c=getchar()));
	for(x=c-48;isdigit(c=getchar());x=x*10+c-48);
}

const int max_N = 5e5 + 21;

int n,q,a[max_N],type,ans;

int seg[max_N<<2],pos[max_N];

#define ls(x) ((x)<<1)
#define rs(x) (ls(x)|1)
#define mid ((l+r)>>1)
#define lch ls(x),l,mid
#define rch rs(x),mid+1,r

inline void update(int x){
	seg[x]=std::__gcd(seg[ls(x)],seg[rs(x)]);
}

void build(int x,int l,int r){
	if(l==r){
		seg[x]=a[l];
		pos[l]=x;
		return;
	}
	build(lch),build(rch);
	update(x);
}

void modify(int x,int y){
	seg[pos[x]]=y;
	for(int i=pos[x]>>1;i;i>>=1)update(i);
}

int ql,qr,qx,qa,qk;

void query(int x,int l,int r){
	if(ql<=l&&r<=qr){
		qx=std::__gcd(qx,seg[x]);
		return;
	}
	if(ql<=mid)query(lch);
	if(qr>mid) query(rch);
}

void biS(int x,int l,int r){
	if(ql<=l&&r<=qr){
		if(l==r){
			qx=std::__gcd(qx,seg[x]);
			if(qa==-1&&(qx%qk)!=0)qa=l;
			return;
		}
		int tmp=std::__gcd(qx,seg[ls(x)]);
		if(!(tmp%qk))qx=tmp,biS(rch);
		else biS(lch);
	}
	else{
		if(ql<=mid)biS(lch);
		if(qr>mid) biS(rch);
	}
}

int main(){
	read(n);
	for(int i=1;i<=n;++i)read(a[i]);
	build(1,1,n);
	read(q);
	while(q--){
		read(type);
		if(type==1){
			read(ql),read(qr),read(qk);
			qx=0,qa=-1;
			biS(1,1,n);
			if(qa==-1)ans=1;
			else if(ql==qr||qa==qr)ans=1;
			else{
				ql=qa+1,qx=0;
				query(1,1,n);
				ans=!(qx%qk);
			}
			puts(ans?"YES":"NO");
		}
		else{
			int x,y;
			read(x),read(y);
			modify(x,y);
		}
	}
	return 0;
}
```

## [E. Palindromes in a Tree](http://codeforces.com/contest/914/problem/E)

**题目大意：**

给出一棵$n\le2\times10^5$的树，每个节点都有且只有一个字符(小写字母$a-t$)。对每一个节点，询问有多少条经过它的路径（交换起点终点算同一条路径）组成的字符串是回文的。

**题解：**

注意到字符只有$20$种，因此可以状压每种字符的奇偶性，枚举哪个字符有奇数个，树分治即可。

树分治的时候不光要统计当前重心的答案，还要顺便统计访问到的节点的答案。

注意对于非重心节点，以当前子树内的任意一个点作为端点的路径都会对它做贡献。

注意对于重心节点，有的路径在两个端点处都计算了，需要对这一部分除以$2$进行去重。

时间复杂度$O(\alpha n\log{n})$，$\alpha$为字符集大小$20$.

```c++
#include <bits/stdc++.h>

const int max_N = 2e5 + 21;

const int max_S = 1<<20;

using ll = long long;

bool vis[max_N];

char s[max_N];

ll ans[max_N];

std::vector<int>vec[max_N],mem[max_N];

int n,rt,siz[max_N],max[max_N],dis[max_N],cnt[max_S];

int find_p(int x,int p,int Sum){
	siz[x]=1,max[x]=0;
	for(auto&y:vec[x])
		if(y!=p&&!vis[y]){
			siz[x]+=find_p(y,x,Sum);
			max[x]=std::max(max[x],siz[y]);
		}
	max[x]=std::max(max[x],Sum-siz[x]);
	if(max[x]<max[rt])rt=x;
	return siz[x];
}

void dfs1(int x,int p,std::vector<int>&mem){
	mem.push_back(x);
	dis[x]=dis[p]^(1<<(s[x]-'a'));
	++cnt[dis[x]];
	for(auto&y:vec[x])
		if(y!=p&&!vis[y]){
			dfs1(y,x,mem);
		}
}

ll dfs2(int x,int p,int rt){
	ll res=0;
	res+=cnt[dis[x]^rt];
	for(int i=0;i<20;++i)
		res+=cnt[dis[x]^rt^(1<<i)];
	for(auto&y:vec[x])
		if(y!=p&&!vis[y]){
			res+=dfs2(y,x,rt);
		}
	ans[x]+=res;
	return res;
}

void solve(int x){
	vis[x]=1;
	++cnt[dis[x]=0];
	mem[x]={x};
	for(auto&y:vec[x])if(!vis[y]){
		dfs1(y,x,mem[y]);
	}
	ll tmp=0;
	for(auto&y:vec[x])if(!vis[y]){
		for(auto&i:mem[y])--cnt[dis[i]];
		tmp+=dfs2(y,x,1<<(s[x]-'a'));
		for(auto&i:mem[y]){
			++cnt[dis[i]];
			int t=dis[i]^(1<<(s[x]-'a'));
			if(!t||t==(t&-t))++tmp;
			mem[x].push_back(i);
		}
		mem[y].clear();
	}
	ans[x]+=tmp/2+1;
	for(auto&i:mem[x])--cnt[dis[i]];
	mem[x].clear();
	for(auto&y:vec[x])if(!vis[y]){
		rt=0;
		find_p(y,x,siz[y]);
		solve(rt);
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1,u,v;i<n;++i){
		scanf("%d%d",&u,&v);
		vec[u].push_back(v);
		vec[v].push_back(u);
	}
	scanf("%s",s+1);
	max[rt=0]=n+1;
	find_p(1,0,n);
	solve(rt);
	for(int i=1;i<=n;++i){
		printf("%I64d%c",ans[i]," \n"[i==n]);
	}
	return 0;
}
```

## [F. Substrings in a String](http://codeforces.com/contest/914/problem/F)

**题目大意**：

给出一个长度为$n\le10^5$的只由小写字母组成的字符串$s$，之后给出$q$次操作，每次操作是以下两种之一：

- 修改字符串$s$的位置$x$为给定的小写字母

- 给出一个字符串$t$，问它在$s[l\cdots r]$中出现的次数

保证第二种操作中字符串的总长度不超过$10^5$


