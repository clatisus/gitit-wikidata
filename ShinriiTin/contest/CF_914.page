# [Codecraft-18 and Codeforces Round #458 (Div. 1 + Div. 2, combined)](http://codeforces.com/contest/914)

## [A. Perfect Squares](http://codeforces.com/contest/914/problem/A)

签到题，求输入的数中不是平方数的最大的数是多少。**居然因为打漏了一个等号fst了!**

## [B. Conan and Agasa play a Card Game](http://codeforces.com/contest/914/problem/B)

**题目大意：**

Conan和Agasa玩游戏，有$n$种卡片，第$i$种卡片有$a_i$张，两人轮流操作，每次操作选择一张剩下的卡片，将它和所有数量比它少的种类的卡片都删掉，无法进行操作的人输。Conan先手，问双方都采取最优策略的情况下谁会获胜。

**题解：**

显然只要有一种卡片的数量是奇数，就是先手赢，否则后手赢。

## [C. Travelling Salesman and Special Numbers](http://codeforces.com/contest/914/problem/C)

**题目大意：**

定义$f(x)$为$x$二进制下$1$的个数，$g(x)$为$x$最少经过多少次$f$变换后会变成$1$。求不大于$1\le n<2^{1000}$的$0\le g(x)=k\le1000$的数的个数，对$10^9+7$取模。

**题解：**

因为$n<2^{1000}$，所以会对答案作贡献的数，经过一次$f$变换后一定不大于$1000$，因此可以预处理出$1000$以内的数的$g(x)$，然后枚举$g(x)=k-1$，去统计不大于$n$的二进制下有$x$个$1$的数的个数即可。

**注意特判$k=1$时，一定会多算一个$1$的贡献。**

```c++
#include <bits/stdc++.h>

const int max_N = 1e3 + 21;

const int mod = 1e9 + 7;

char s[max_N];

int sum[max_N];

int n,k,C[max_N][max_N];

int f[max_N],cnt[max_N];

inline int calc(int k){
	int res=0;
	for(int i=0;i<n;++i){
		if(i&&sum[i-1]>k)continue;
		if(s[i]!='1')continue;
		if(n-i-1<k-(i?sum[i-1]:0))continue;
		res=(res+C[n-i-1][k-(i?sum[i-1]:0)])%mod;
	}
	if(k==sum[n-1])(++res)%=mod;
	return res;
}

int main(){
	C[0][0]=1;
	for(int i=1;i<=1000;++i){
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;++j){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		}
	}
	for(int i=1;i<=1000;++i){
		cnt[i]=cnt[i-(i&-i)]+1;
	}
	for(int i=2;i<=1000;++i){
		f[i]=f[cnt[i]]+1;
	}
	scanf("%s%d",s,&k);
	n=strlen(s);
	if(n==1&&s[0]=='1'&&k==1){
		puts("0");
		return 0;
	}
	for(int i=0;i<n;++i){
		sum[i]=(s[i]=='1');
		if(i)sum[i]+=sum[i-1];
	}
	int ans=0;
	for(int i=1;i<=1000;++i)
		if(f[i]==k-1){
			ans=(ans+calc(i))%mod;
		}
	if(!k)ans=1;
	else if(k==1)ans=(ans-1+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```

## [D. Bash and a Tough Math Puzzle](http://codeforces.com/contest/914/problem/D)

**题目大意：**

有一个长度为$n\le5\times10^5$的数组$a$，接下来$q\le4\times10^5$次操作，每次操作是以下两种之一：

- 询问区间 $[l,r]$ 是否可以最多只改变一个位置的数，使得区间的$gcd$等于$x$；

- 将位置$i$的数修改为$y$；

**题解：**

用线段树维护区间$gcd$，询问时二分找到最小的$i$，使得$[l,i]$的$gcd$不被$x$整除，然后尝试修改$a_i$，查询$[i+1,r]$区间的$gcd$，判断其是否能被$x$整除即可。修改则直接修改。

在线段树上二分，复杂度$O(n\log{n})$乘上求$gcd$的复杂度。

```c++
#include <bits/stdc++.h>

template<typename T>inline void read(T&x){
	register char c; while(!isdigit(c=getchar()));
	for(x=c-48;isdigit(c=getchar());x=x*10+c-48);
}

const int max_N = 5e5 + 21;

int n,q,a[max_N],type,ans;

int seg[max_N<<2],pos[max_N];

#define ls(x) ((x)<<1)
#define rs(x) (ls(x)|1)
#define mid ((l+r)>>1)
#define lch ls(x),l,mid
#define rch rs(x),mid+1,r

inline void update(int x){
	seg[x]=std::__gcd(seg[ls(x)],seg[rs(x)]);
}

void build(int x,int l,int r){
	if(l==r){
		seg[x]=a[l];
		pos[l]=x;
		return;
	}
	build(lch),build(rch);
	update(x);
}

void modify(int x,int y){
	seg[pos[x]]=y;
	for(int i=pos[x]>>1;i;i>>=1)update(i);
}

int ql,qr,qx,qa,qk;

void query(int x,int l,int r){
	if(ql<=l&&r<=qr){
		qx=std::__gcd(qx,seg[x]);
		return;
	}
	if(ql<=mid)query(lch);
	if(qr>mid) query(rch);
}

void biS(int x,int l,int r){
	if(ql<=l&&r<=qr){
		if(l==r){
			qx=std::__gcd(qx,seg[x]);
			if(qa==-1&&(qx%qk)!=0)qa=l;
			return;
		}
		int tmp=std::__gcd(qx,seg[ls(x)]);
		if(!(tmp%qk))qx=tmp,biS(rch);
		else biS(lch);
	}
	else{
		if(ql<=mid)biS(lch);
		if(qr>mid) biS(rch);
	}
}

int main(){
	read(n);
	for(int i=1;i<=n;++i)read(a[i]);
	build(1,1,n);
	read(q);
	while(q--){
		read(type);
		if(type==1){
			read(ql),read(qr),read(qk);
			qx=0,qa=-1;
			biS(1,1,n);
			if(qa==-1)ans=1;
			else if(ql==qr||qa==qr)ans=1;
			else{
				ql=qa+1,qx=0;
				query(1,1,n);
				ans=!(qx%qk);
			}
			puts(ans?"YES":"NO");
		}
		else{
			int x,y;
			read(x),read(y);
			modify(x,y);
		}
	}
	return 0;
}
```

## [E. Palindromes in a Tree](http://codeforces.com/contest/914/problem/E)

**题目大意：**

给出一棵$n\le2\times10^5$的树，每个节点都有且只有一个字符(小写字母$a-t$)。对每一个节点，询问有多少条经过它的路径（交换起点终点算同一条路径）组成的字符串是回文的。

**题解：**

注意到字符只有$20$种，因此可以状压每种字符的奇偶性，枚举哪个字符有奇数个，树分治即可。

树分治的时候不光要统计当前重心的答案，还要顺便统计访问到的节点的答案。

注意对于非重心节点，以当前子树内的任意一个点作为端点的路径都会对它做贡献。

注意对于重心节点，有的路径在两个端点处都计算了，需要对这一部分除以$2$进行去重。

时间复杂度$O(\alpha n\log{n})$，$\alpha$为字符集大小$20$.

```c++
#include <bits/stdc++.h>

const int max_N = 2e5 + 21;

const int max_S = 1<<20;

using ll = long long;

bool vis[max_N];

char s[max_N];

ll ans[max_N];

std::vector<int>vec[max_N],mem[max_N];

int n,rt,siz[max_N],max[max_N],dis[max_N],cnt[max_S];

int find_p(int x,int p,int Sum){
	siz[x]=1,max[x]=0;
	for(auto&y:vec[x])
		if(y!=p&&!vis[y]){
			siz[x]+=find_p(y,x,Sum);
			max[x]=std::max(max[x],siz[y]);
		}
	max[x]=std::max(max[x],Sum-siz[x]);
	if(max[x]<max[rt])rt=x;
	return siz[x];
}

void dfs1(int x,int p,std::vector<int>&mem){
	mem.push_back(x);
	dis[x]=dis[p]^(1<<(s[x]-'a'));
	++cnt[dis[x]];
	for(auto&y:vec[x])
		if(y!=p&&!vis[y]){
			dfs1(y,x,mem);
		}
}

ll dfs2(int x,int p,int rt){
	ll res=0;
	res+=cnt[dis[x]^rt];
	for(int i=0;i<20;++i)
		res+=cnt[dis[x]^rt^(1<<i)];
	for(auto&y:vec[x])
		if(y!=p&&!vis[y]){
			res+=dfs2(y,x,rt);
		}
	ans[x]+=res;
	return res;
}

void solve(int x){
	vis[x]=1;
	++cnt[dis[x]=0];
	mem[x]={x};
	for(auto&y:vec[x])if(!vis[y]){
		dfs1(y,x,mem[y]);
	}
	ll tmp=0;
	for(auto&y:vec[x])if(!vis[y]){
		for(auto&i:mem[y])--cnt[dis[i]];
		tmp+=dfs2(y,x,1<<(s[x]-'a'));
		for(auto&i:mem[y]){
			++cnt[dis[i]];
			int t=dis[i]^(1<<(s[x]-'a'));
			if(!t||t==(t&-t))++tmp;
			mem[x].push_back(i);
		}
		mem[y].clear();
	}
	ans[x]+=tmp/2+1;
	for(auto&i:mem[x])--cnt[dis[i]];
	mem[x].clear();
	for(auto&y:vec[x])if(!vis[y]){
		rt=0;
		find_p(y,x,siz[y]);
		solve(rt);
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1,u,v;i<n;++i){
		scanf("%d%d",&u,&v);
		vec[u].push_back(v);
		vec[v].push_back(u);
	}
	scanf("%s",s+1);
	max[rt=0]=n+1;
	find_p(1,0,n);
	solve(rt);
	for(int i=1;i<=n;++i){
		printf("%I64d%c",ans[i]," \n"[i==n]);
	}
	return 0;
}
```

## [F. Substrings in a String](http://codeforces.com/contest/914/problem/F)

**题目大意**：

给出一个长度为$n\le10^5$的只由小写字母组成的字符串$s$，之后给出$q$次操作，每次操作是以下两种之一：

- 修改字符串$s$的位置$x$为给定的小写字母

- 给出一个字符串$t$，问它在$s[l\cdots r]$中出现的次数

保证第二种操作中字符串的总长度不超过$10^5$

**题解**：

因为询问的字符串总长度不超过$10^5$，我们可以取$K$约等于$\sqrt{10^5}$，这样操作2中长度大于$K$的串最多有$\sqrt{10^5}$个，这些串直接和$s$串进行一次`kmp`即可。


对于长度不大于$K$的询问串$t$，我们将$s$按大小$K$分块，这样就保证了$t$只会出现在$s$的某块内或者是横跨相邻两块。

对于$s$的每一块，维护一个`sam`来计算块内的出现次数，每当修改的时候重新构建这一块的`sam`。

对于横跨两块的部分，只需要拿出$2(|t|-1)$长的部分与$t$做一次`kmp`即可。

总的时间复杂度$O(n\sqrt{n})$，空间复杂度$O(n)$。

```c++
#include <bits/stdc++.h>

//#define debug

const int max_N = 1e5 + 21;

const int sqrt_N = 400 + 21;

const int sigma = 26;

#ifdef debug

const int K = 5;

#else

const int K = 400;

#endif

using star = struct node*;

struct node{
	int len,siz;
	star par,trans[sigma];
	void clone(star x,int n){
		siz=0,len=n;
		par=x->par;
		for(int i=0;i<sigma;++i)
			trans[i]=x->trans[i];
		x->par=this;
	}
};

struct sam{
	node pool[sqrt_N<<1];
	star rt,last,tail;
	int cnt[sqrt_N],Q[sqrt_N<<1];
	star append(int c,int n){
		star p,q,r,cur=tail++;
		cur->len=n,cur->siz=1;
		for(int i=0;i<sigma;++i)
			cur->trans[i]=0;
		for(p=last;p&&!p->trans[c];p=p->par)
			p->trans[c]=cur;
		if(!p)cur->par=rt;
		else{
			q=p->trans[c];
			if(p->len+1==q->len)
				cur->par=q;
			else{
				r=tail++;
				r->clone(q,p->len+1);
				for(;p&&p->trans[c]==q;p=p->par)
					p->trans[c]=r;
				cur->par=r;
			}
		}
		return cur;
	}
	void build(char*s,int n){
		tail=pool;
		last=rt=tail++;
		rt->par=0;
		rt->len=rt->siz=0;
		for(int i=0;i<sigma;++i)
			rt->trans[i]=0;
		for(int i=0;i<n;++i){
			last=append(s[i]-'a',i+1);
		}
		for(int i=0;i<=n;++i)cnt[i]=0;
		for(star p=pool;p<tail;++p)++cnt[p->len];
		for(int i=1;i<=n;++i)cnt[i]+=cnt[i-1];
		for(star p=tail-1;p>pool;--p)
			Q[--cnt[p->len]]=p-pool;
		for(int i=tail-pool-1;~i;--i){
			star p=pool+Q[i];
			if(p->par)p->par->siz+=p->siz;
		}
	}
	int count(char*s,int n){
		star p=rt;
		for(int i=0;i<n;++i){
			if(!p->trans[s[i]-'a'])return 0;
			p=p->trans[s[i]-'a'];
		}
		return p->siz;
	}
}SAM[sqrt_N];

int n,m,q,fail[max_N];

char s[max_N],t[max_N];

void get_fail(char*t,int m){
	fail[0]=-1;
	for(int i=1,j;i<m;++i){
		for(j=fail[i-1];~j&&t[j+1]!=t[i];j=fail[j]);
		fail[i]=t[j+1]==t[i]?j+1:-1;
	}
}

int kmp(char*s,int n,char*t,int m){
	int res=0;
	for(int i=0,j=-1;i<n;++i){
		while(~j&&s[i]!=t[j+1])j=fail[j];
		if(s[i]==t[j+1])++j;
		if(j==m-1){
			++res;
			j=fail[j];
		}
	}
	return res;
}

int main(){
#ifdef debug
	freopen("input.txt","r",stdin);
	freopen("main.out","w",stdout);
#endif
	scanf("%s",s);
	n=strlen(s);
	for(int a=0,i=0;a<n;++i,a+=K){
		int b=std::min(a+K,n);
		SAM[i].build(s+a,b-a);
	}
	scanf("%d",&q);
	while(q--){
		int opt,x,l,r; scanf("%d",&opt);
		if(opt==1){
			scanf("%d%s",&x,t);
			s[--x]=t[0];
			int i=x/K,a=i*K,b=std::min(a+K,n);
			SAM[i].build(s+a,b-a);
		}
		else{
			scanf("%d%d%s",&l,&r,t);
			--l,--r;
			get_fail(t,m=strlen(t));
			if(m>K)
				printf("%d\n",kmp(s+l,r-l+1,t,m));
			else{
				int res=0,lx=l/K,rx=r/K;
				for(int i=lx+1;i<rx;++i)
					res+=SAM[i].count(t,m);
				for(int i=lx+2;i<rx;++i){
					int a=i*K-(m-1),b=i*K+(m-1);
					res+=kmp(s+a,b-a,t,m);	
				}
				if(lx+1>=rx)
					res+=kmp(s+l,r-l+1,t,m);
				else{
					int a=(lx+1)*K+(m-1);
					res+=kmp(s+l,a-l,t,m);
					int b=rx*K-(m-1);
					res+=kmp(s+b,r-b+1,t,m);
				}
				printf("%d\n",res);
			}
		}
	}
	return 0;
}
```


