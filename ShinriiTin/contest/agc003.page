# [AtCoder Grand Contest 003](https://agc003.contest.atcoder.jp)

## [A - Wanna go back home](https://agc003.contest.atcoder.jp/tasks/agc003_a)

**题目大意：**

`Snuke`在无限大的二维坐标平面上从原点出发，进行了$n\le1000$的旅行，已知每天旅行的方向（为东南西北四个方向之一），但距离是任意的，问是否存在一种方案使得最后一天旅行后恰好回到原点。

**题解：**

显然不能回去当且仅当某个方向的旅行存在而其反方向的旅行不存在。

```c++
#include <bits/stdc++.h>

const int max_N = 1e3 + 21;

int n;

bool vis[4];

char s[max_N];

int main(){
	scanf("%s",s);
	n=strlen(s);
	for(int i=0;i<n;++i){
		switch(s[i]){
			case('N'): vis[0]=1; break;	
			case('S'): vis[1]=1; break;
			case('E'): vis[2]=1; break;
			case('W'): vis[3]=1; break;
		}
	}
	if((vis[0]^vis[1])||(vis[2]^vis[3]))puts("No");
	else puts("Yes");
	return 0;
}
```

## [B - Simplified mahjong](https://agc003.contest.atcoder.jp/tasks/agc003_b)

**题目大意：**

有$n\le10^5$种不同的卡片，第$i$种卡片有$0\le a_i\le10^9$张。

第$i$种卡片可以和第$i-1,i,i+1$种卡片之一配对，问最多可以配出多少对。

**题解：**

因为自己可以和自己配对，所以就是要尽可能多的解决掉奇数卡片。

形如`奇奇`，`奇偶奇`，`奇偶偶奇`这样的连续卡片可以完美配对（要求偶数不为零）。

按上面的策略从左往右贪心配对即可，时间复杂度$O(n)$。

```c++
#include <bits/stdc++.h>

using ll = long long;

const int max_N = 1e5 + 21;

int n,A[max_N];

ll ans;

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",A+i);
	for(int i=1,j;i<=n;++i){
		if(A[i]&1){
			for(j=i+1;j<=n&&A[j]>=2&&(~A[j]&1);++j);
			if(A[j]&1){
				ll tmp=0;
				for(int k=i;k<=j;++k)tmp+=A[k];
				ans+=(tmp>>1);
				i=j;
			}
			else ans+=(A[i]>>1);
		}
		else ans+=(A[i]>>1);
	}
	printf("%lld\n",ans);
	return 0;
}
```

## [C - BBuBBBlesort!](https://agc003.contest.atcoder.jp/tasks/agc003_c)

**题目大意：**

给出一个长度为$n\le10^5$的整数数列$a$，数列中的数两两不同，要用以下两种操作将其排序为升序：

- 交换相邻的两个位置（$A_i,A_{i+1}$）

- 交换相隔一个位置的两个位置（$A_i,A_{i+2}$）

求至少要用到多少次第一种操作。

**题解：**

第二种操作可以做到不改变位置奇偶性的任意交换，但是要改变奇偶性必须用到第一种操作。

因此设排序前后位置奇偶性改变的数有$k$个，则答案为$k/2$。

显然$k$为偶数，因此，可以用第二种操作使其交换到两两相邻，再用$k/2$次第一种操作即可。

时间复杂度为排序复杂度$O(n\log{n})$.

```c++
#include <bits/stdc++.h>

const int max_N = 1e5 + 21;

int n,ans;

std::pair<int,int>A[max_N];

int main(){
	scanf("%d",&n);
	for(int i=1,a;i<=n;++i){
		scanf("%d",&a);
		A[i]={a,i};
	}
	std::sort(A+1,A+1+n);
	for(int i=1;i<=n;++i)
		if((i^A[i].second)&1)++ans;
	printf("%d\n",ans>>1);
	return 0;
}
```

## [D - Anticube](https://agc003.contest.atcoder.jp/tasks/agc003_d)

**题目大意：**

给出一个长度为$n\le10^5$的整数数列$a$，$1\le a_i\le10^{10}$。

要从数列中选出尽可能多的数，满足被选出的数中，任意两个数的乘积不是立方数。

输出最多可以选出的数的数量。

**题解：**

定义$Norm(t)$为$t$去掉所有立方因子后剩余的部分，$Pair(t)$为令$t\times Pair(t)$为立方数的最小的数。

那么$a\times b$为立方数当且仅当$Norm(a)=Pair(b)$，并且显然此时$Pair(a)=Norm(b)$也成立。

如果知道每个数的$Norm$与$Pair$，则$\displaystyle ans=[|\{t|Norm(t)=x\}|>0]+\frac{\sum\limits_{x=2}\max(|\{t|Norm(t)=x\}|,|\{t|Pair(t)=x\}|)}{2}$.

利用线性筛求出$10^{\frac{10}{3}}$以内的质数。

$Norm(t)$直接枚举$t^{\frac{1}{3}}$以内的质数试除即可。

$Pair(t)$同样枚举$t^{\frac{1}{3}}$以内的质数，这一部分需要补上的因子就计算完毕了，剩余的部分$s$至多只有两个质因子。

当$s=1$或$s$为质数或$s=p\times q$时，这一部分需要补上的因子都是$s^2$，只有当$s=p^2$时，只需要补上$p$即可。

因此直接对$s$开方判断其是否为平方数即可。

时间复杂度为$O(maxA_i^{1/3}+\frac{n\times maxA_i^{1/3}}{\log{maxA_i}}+n\log{n})$.

需要注意的是$Pair(t)$可能会很大，超出`long long int`的范围。

但是因为$Norm(t)\le t\le10^10$，这样大的$Pair(t)$是找不到与其匹配的$Norm(t)$的。

因此计算过程中简单判断一下是否会超出一个足够大的上限，会的话直接令其等于上限即可，不影响计算结果。

```c++
#include <bits/stdc++.h>
 
using ll = long long;
 
const int max_N = 1e5 + 21;

const ll inf = 2e10 + 1;
 
int n,ans;
 
bool vis[max_N];

int pri_tot,pri[max_N];
 
ll Norm[max_N],Pair[max_N];

int N_tot,P_tot,N_siz[max_N],P_siz[max_N];

inline void jzp(int n){
	for(int x=2;x<=n;++x){
		if(!vis[x])pri[++pri_tot]=x;
		for(int i=1;i<=pri_tot;++i){
			int y=pri[i];
			if((ll)x*y>n)break;
			vis[x*y]=1;
			if(!(x%y))break;
		}
	}
}
 
inline ll get_norm(ll x){
	for(int i=1;i<=pri_tot;++i){
		int y=pri[i];
		ll z=1ll*y*y*y;
		if(z>x)break;
		while(!(x%z))x/=z;
	}
	return x;
}
 
inline ll get_pair(ll x){
	ll res=1;
	for(int i=1;i<=pri_tot;++i){
		int y=pri[i];
		ll z=(ll)y*y*y;
		if(z<=x){
			while(!(x%z))x/=z;
			if(!(x%(y*y))){
				res*=y,x/=(y*y);
				if(res>=inf)return inf;
			}
			else if(!(x%y)){
				res*=(y*y),x/=y;
				if(res>=inf)return inf;
			}
		}
		else break;
	}
	ll y=std::sqrt(x);
	if(y*y==x){
		res*=y;
		return res>=inf?inf:res;
	}
	if(inf/x/x<res)return inf;
	return res*x*x;
}
 
int main(){
	jzp(1e5);
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		ll s; scanf("%lld",&s);
		Norm[i]=get_norm(s);
		Pair[i]=get_pair(s);
	}
	std::sort(Norm+1,Norm+1+n);
	std::sort(Pair+1,Pair+1+n);
	for(int i=1;i<=n;++i){
		if(Norm[i]!=Norm[i-1])Norm[++N_tot]=Norm[i];
		++N_siz[N_tot];
		if(Pair[i]!=Pair[i-1])Pair[++P_tot]=Pair[i];
		++P_siz[P_tot];
	}
	int i=1,j=1;
	while(i<=N_tot||j<=P_tot){
		if(i<=N_tot&&j<=P_tot&&Norm[i]==Pair[j]){
			if(Norm[i]!=1)ans+=std::max(N_siz[i],P_siz[j]);
			++i,++j;
		}
		else if(i>N_tot||(j<=P_tot&&Norm[i]>Pair[j]))
			ans+=P_siz[j++];
		else
			ans+=N_siz[i++];
	}
	ans>>=1;
	if(Norm[1]==1)++ans;
	printf("%d\n",ans);
	return 0;
}
```
