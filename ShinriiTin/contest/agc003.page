# [AtCoder Grand Contest 003](https://agc003.contest.atcoder.jp)

## [A - Wanna go back home](https://agc003.contest.atcoder.jp/tasks/agc003_a)

**题目大意：**

`Snuke`在无限大的二维坐标平面上从原点出发，进行了$n\le1000$的旅行，已知每天旅行的方向（为东南西北四个方向之一），但距离是任意的，问是否存在一种方案使得最后一天旅行后恰好回到原点。

**题解：**

显然不能回去当且仅当某个方向的旅行存在而其反方向的旅行不存在。

```c++
#include <bits/stdc++.h>

const int max_N = 1e3 + 21;

int n;

bool vis[4];

char s[max_N];

int main(){
	scanf("%s",s);
	n=strlen(s);
	for(int i=0;i<n;++i){
		switch(s[i]){
			case('N'): vis[0]=1; break;	
			case('S'): vis[1]=1; break;
			case('E'): vis[2]=1; break;
			case('W'): vis[3]=1; break;
		}
	}
	if((vis[0]^vis[1])||(vis[2]^vis[3]))puts("No");
	else puts("Yes");
	return 0;
}
```

## [B - Simplified mahjong](https://agc003.contest.atcoder.jp/tasks/agc003_b)

**题目大意：**

有$n\le10^5$种不同的卡片，第$i$种卡片有$0\le a_i\le10^9$张。

第$i$种卡片可以和第$i-1,i,i+1$种卡片之一配对，问最多可以配出多少对。

**题解：**

因为自己可以和自己配对，所以就是要尽可能多的解决掉奇数卡片。

形如`奇奇`，`奇偶奇`，`奇偶偶奇`这样的连续卡片可以完美配对（要求偶数不为零）。

按上面的策略从左往右贪心配对即可，时间复杂度$O(n)$。

```c++
#include <bits/stdc++.h>

using ll = long long;

const int max_N = 1e5 + 21;

int n,A[max_N];

ll ans;

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",A+i);
	for(int i=1,j;i<=n;++i){
		if(A[i]&1){
			for(j=i+1;j<=n&&A[j]>=2&&(~A[j]&1);++j);
			if(A[j]&1){
				ll tmp=0;
				for(int k=i;k<=j;++k)tmp+=A[k];
				ans+=(tmp>>1);
				i=j;
			}
			else ans+=(A[i]>>1);
		}
		else ans+=(A[i]>>1);
	}
	printf("%lld\n",ans);
	return 0;
}
```