# [AtCoder Grand Contest 002](https://agc002.contest.atcoder.jp)

## [A - Range Product](https://agc002.contest.atcoder.jp/tasks/agc002_a)

**题目大意：**

判断$\prod\limits_{i=a}^{b}i$的正负号或者是$0$，$-10^9\le a\le b\le10^9$.

**题解：**

先判断是否为$0$，然后根据负数因子的个数回答即可。

```c++
#include <bits/stdc++.h>

int a,b;

int main(){
	scanf("%d%d",&a,&b);
	if(a<=0&&0<=b)puts("Zero");
	else if(a>0)puts("Positive");
	else puts(((b-a)&1)?"Positive":"Negative");
	return 0;
}
```

## [B - Box and Ball](https://agc002.contest.atcoder.jp/tasks/agc002_b)

**题目大意：**

有$n\le10^5$个盒子，一开始$1$号盒子中有一个红球，其它每个盒子中有一个白球。

接下来$m$次操作，每次操作从$x$号盒子中随机取出一个球放入$y$号盒子，保证$x\not=y$，且$x$号盒子此时至少有一个球。

问最后有多少个盒子中可能存在红球。

**题解：**

令$f_i$表示$i$号盒子中可能有红球，$siz_i$为$i$号盒子中球的数量。

则一开始$f_1=1,siz_i=1$，每次操作，$f^{'}_y=f_x\lor f_y$，如果操作后$siz_x=0$，则令$f_x=0$，否则不变。

最后扫一遍$f_i=1$的盒子数量即可，时间复杂度$O(n)$.

```c++
#include <bits/stdc++.h>

const int max_N = 1e5 + 21;

int n,m,ans,siz[max_N];

bool f[max_N];

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)siz[i]=1;
	f[1]=1;
	while(m--){
		int x,y; scanf("%d%d",&x,&y);
		++siz[y],f[y]|=f[x];
		if(!--siz[x])f[x]=0;
	}
	for(int i=1;i<=n;++i)if(f[i])++ans;
	printf("%d\n",ans);
	return 0;
}
```

## [C - Knot Puzzle](https://agc002.contest.atcoder.jp/tasks/agc002_c)

**题目大意：**

有$n\le10^5$段绳子，第$i$段绳子的长度为$a_i$，第$i$段和第$i+1$段绳子被第$i$个结系在一起。

如果一段绳子的总长度不小于$L$，那么就可以解开这段绳子中的任意一个结，问是否存在一种方案将$n-1$个结都解开。

**题解：**

考虑最后一个结，它能被解开的充要条件是连接的相邻两段绳子的长度和不小于$L$，如果不存在这样的结，显然无解。

如果存在，那么按离这个结的从远到近的顺序解开两边的结最后再解开这个结即可。

```c++
#include <bits/stdc++.h>

const int max_N = 1e5 + 21;

int n,pos,tot,ans[max_N],a[max_N],L;

int main(){
	scanf("%d%d",&n,&L);
	for(int i=1;i<=n;++i)scanf("%d",a+i);
	for(int i=1;i<n;++i)
		if(a[i]+a[i+1]>=L){pos=i; break;}
	if(!pos)return puts("Impossible"),0;
	puts("Possible");
	for(int i=1;i<pos;++i)ans[++tot]=i;
	for(int i=n-1;i>=pos;--i)ans[++tot]=i;
	for(int i=1;i<=tot;++i)printf("%d\n",ans[i]);
	return 0;
}
```
