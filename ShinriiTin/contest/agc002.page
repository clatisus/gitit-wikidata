# [AtCoder Grand Contest 002](https://agc002.contest.atcoder.jp)

## [A - Range Product](https://agc002.contest.atcoder.jp/tasks/agc002_a)

**题目大意：**

判断$\prod\limits_{i=a}^{b}i$的正负号或者是$0$，$-10^9\le a\le b\le10^9$.

**题解：**

先判断是否为$0$，然后根据负数因子的个数回答即可。

```c++
#include <bits/stdc++.h>

int a,b;

int main(){
	scanf("%d%d",&a,&b);
	if(a<=0&&0<=b)puts("Zero");
	else if(a>0)puts("Positive");
	else puts(((b-a)&1)?"Positive":"Negative");
	return 0;
}
```

## [B - Box and Ball](https://agc002.contest.atcoder.jp/tasks/agc002_b)

**题目大意：**

有$n\le10^5$个盒子，一开始$1$号盒子中有一个红球，其它每个盒子中有一个白球。

接下来$m$次操作，每次操作从$x$号盒子中随机取出一个球放入$y$号盒子，保证$x\not=y$，且$x$号盒子此时至少有一个球。

问最后有多少个盒子中可能存在红球。

**题解：**

令$f_i$表示$i$号盒子中可能有红球，$siz_i$为$i$号盒子中球的数量。

则一开始$f_1=1,siz_i=1$，每次操作，$f^{'}_y=f_x\lor f_y$，如果操作后$siz_x=0$，则令$f_x=0$，否则不变。

最后扫一遍$f_i=1$的盒子数量即可，时间复杂度$O(n)$.

```c++
#include <bits/stdc++.h>

const int max_N = 1e5 + 21;

int n,m,ans,siz[max_N];

bool f[max_N];

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)siz[i]=1;
	f[1]=1;
	while(m--){
		int x,y; scanf("%d%d",&x,&y);
		++siz[y],f[y]|=f[x];
		if(!--siz[x])f[x]=0;
	}
	for(int i=1;i<=n;++i)if(f[i])++ans;
	printf("%d\n",ans);
	return 0;
}
```

## [C - Knot Puzzle](https://agc002.contest.atcoder.jp/tasks/agc002_c)

**题目大意：**

有$n\le10^5$段绳子，第$i$段绳子的长度为$a_i$，第$i$段和第$i+1$段绳子被第$i$个结系在一起。

如果一段绳子的总长度不小于$L$，那么就可以解开这段绳子中的任意一个结，问是否存在一种方案将$n-1$个结都解开。

**题解：**

考虑最后一个结，它能被解开的充要条件是连接的相邻两段绳子的长度和不小于$L$，如果不存在这样的结，显然无解。

如果存在，那么按离这个结的从远到近的顺序解开两边的结最后再解开这个结即可。

```c++
#include <bits/stdc++.h>

const int max_N = 1e5 + 21;

int n,pos,tot,ans[max_N],a[max_N],L;

int main(){
	scanf("%d%d",&n,&L);
	for(int i=1;i<=n;++i)scanf("%d",a+i);
	for(int i=1;i<n;++i)
		if(a[i]+a[i+1]>=L){pos=i; break;}
	if(!pos)return puts("Impossible"),0;
	puts("Possible");
	for(int i=1;i<pos;++i)ans[++tot]=i;
	for(int i=n-1;i>=pos;--i)ans[++tot]=i;
	for(int i=1;i<=tot;++i)printf("%d\n",ans[i]);
	return 0;
}
```

## [D - Stamp Rally](https://agc002.contest.atcoder.jp/tasks/agc002_d)

**题目大意：**

给出一张无向连通图，点数和边数分别为$1\le n,m\le10^5$。

有$q\le10^5$次询问，每次询问至少需要用到编号不大于多少的边，才能使得与$x$和$y$两个点至少一个点连通的点数不少于$z$.

**题解：**

**方法一：**

考虑对边分块，取块大小$K=\sqrt{m}$，用并查集维护连通块大小，先找到每组询问答案所在块编号，再枚举答案判断。

时间复杂度$O(q\sqrt{m}+n+m)$，空间复杂度$O(n+m+q)$.

```c++
#include <bits/stdc++.h>

//#define debug

const int max_N = 1e5 + 21;

#ifdef debug
const int K = 4;
#else
const int K = 400;
#endif

int n,m,q,u[max_N],v[max_N];

int x[max_N],y[max_N],z[max_N],ans[max_N];

struct dfu{
	int f[max_N],siz[max_N];
	int find(int x){
		return f[x]==x?x:f[x]=find(f[x]);
	}
	void merge(int x,int y){
		x=find(x),y=find(y);
		if(x==y)return;
		if(siz[x]>siz[y])std::swap(x,y);
		siz[y]+=siz[x],f[x]=y;
	}
}F[2];

std::vector<int>Q[2],Q2;

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i)scanf("%d%d",u+i,v+i);
	for(int i=1;i<=n;++i){
		F[0].f[i]=i,F[0].siz[i]=1;
		F[1].f[i]=i,F[1].siz[i]=1;
	}
	scanf("%d",&q);
	for(int i=1;i<=q;++i){
		scanf("%d%d%d",x+i,y+i,z+i);
		Q[0].push_back(i);
	}
	int cur=0,B=(m-1)/K;
	for(int i=0;i<=B;++i){
		for(int j=i*K+1;j<=m&&j<=(i+1)*K;++j)
			F[0].merge(u[j],v[j]);
		Q[cur^1].clear(),Q2.clear();
		for(auto&j:Q[cur]){
			int fx=F[0].find(x[j]),fy=F[0].find(y[j]);
			int siz=(fx==fy)?F[0].siz[fx]:F[0].siz[fx]+F[0].siz[fy];
			if(siz>=z[j])Q2.push_back(j);
			else Q[cur^1].push_back(j);
		}
		for(int j=i*K+1;j<=m&&j<=(i+1)*K;++j){
			F[1].merge(u[j],v[j]);
			for(auto&k:Q2){
				if(ans[k])continue;
				int fx=F[1].find(x[k]),fy=F[1].find(y[k]);
				int siz=(fx==fy)?F[1].siz[fx]:F[1].siz[fx]+F[1].siz[fy];
				if(siz>=z[k])ans[k]=j;
			}
		}
		cur^=1;
	}
	for(int i=1;i<=q;++i)printf("%d\n",ans[i]);
	return 0;
}
```

**方法二：**

单独考虑每组询问，显然可以二分答案，并查集判断。

于是我们使用整体二分，但是每次重建并查集代价太高，可以考虑按`bfs`的顺序访问整体二分的树结构。

这样每层的区间中点是有序的，按顺序加边即可，而进入新的一层的时候则需要重置并查集。

因为二分的树结构只有$O(\log{m})$层，因此时间复杂度为$O((n+m+q)\log{m})$.

```c++
#include <bits/stdc++.h>

//#define debug

const int max_N = 1e5 + 21;

int n,m,q,cur,u[max_N],v[max_N];

int x[max_N],y[max_N],z[max_N],ans[max_N];

int f[max_N],siz[max_N];

void dfu_init(){
	for(int i=1;i<=n;++i)f[i]=i,siz[i]=1;
}

int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}

void merge(int x,int y){
	x=find(x),y=find(y);
	if(x==y)return;
	if(siz[x]>siz[y])std::swap(x,y);
	siz[y]+=siz[x],f[x]=y;
}

using star = struct node*;

struct node{
	int l,r;
	std::vector<int>vec;
}pool[max_N*20];

star tail=pool;

std::queue<star>Q;

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i)scanf("%d%d",u+i,v+i);
	scanf("%d",&q);
	star rt=tail++;
	rt->l=1,rt->r=m,Q.push(rt);
	for(int i=1;i<=q;++i){
		scanf("%d%d%d",x+i,y+i,z+i);
		rt->vec.push_back(i);
	}
	dfu_init();
	while(!Q.empty()){
		star it=Q.front(); Q.pop();
		if(it->vec.empty())continue;
		if(it->l==it->r){
			for(auto&i:it->vec)ans[i]=it->l;
			continue;
		}
		int mid=(it->l+it->r)>>1;
		if(cur>mid)dfu_init(),cur=0;
		while(cur<mid)++cur,merge(u[cur],v[cur]);
		star lch=tail++,rch=tail++;
		lch->l=it->l,lch->r=mid,rch->l=mid+1,rch->r=it->r;
		for(auto&i:it->vec){
			int fx=find(x[i]),fy=find(y[i]);
			int sz=(fx==fy)?siz[fx]:siz[fx]+siz[fy];
			if(sz>=z[i])lch->vec.push_back(i);
			else rch->vec.push_back(i);
		}
		Q.push(lch),Q.push(rch);
	}
	for(int i=1;i<=q;++i)printf("%d\n",ans[i]);
	return 0;
}
```
