# 计数与期望问题选讲

## [K Perm Counting](https://agc005.contest.atcoder.jp/tasks/agc005_d)

**题目大意：**

求有多少个$1$到$n$的排列$a$，满足$\forall 1\le i\le n\to|a_i-i|\not=k$.

$2\le n\le2000,1\le k\le n-1$.

**题解：**

令$f[i]$表示选择$i$个数并决定它们的位置，使得这$i$个数都满足$|a_i-i|=k$，即$a_i$可以是$i-k$或$i+k$，的方案数。

则由容斥原理可得$\displaystyle ans=\sum\limits_{i=0}^n f[i]\times(n-i)!\times(-1)^i$.

接下来介绍如何计算$f[i]$.

将$1$到$n$按$\mod{k}$的余数分组，则不同的组之间相互独立。

对于同组的情况，我们考虑一个dp，令$g[i][j][mask]$表示只考虑前$i$个数，一共选了$j$个数，最右边的两个数是否占用了$x+k$位置的状态为$mask$的方案数。

则有递归基：

$$g[1][0][0]=1,g[1][1][1]=1$$

以及转移方程：

$$\displaystyle\begin{aligned}g[i][j][0]&=g[i-1][j][0]+g[i-1][j][2]+g[i-1][j-1][0]\\g[i][j][1]&=g[i-1][j-1][0]+g[i-1][j-1][2]\\g[i][j][2]&=g[i-1][j][1]+g[i-1][j][3]+g[i-1][j-1][1]\\g[i][j][3]&=g[i-1][j-1][1]+g[i-1][j-1][3]\end{aligned}$$

令$getS(i,j)=g[i][j][0]+g[i][j][2]$，则可以做一个分组背包来计算$f[i]$：

枚举$\mod{k}$的余数$x$，然后枚举这一组选择的数量$i$，则背包时应该用$f[i]+=f[i-j]\times getS(siz[x],i)$更新，其中$siz[x]$为该组的大小。

计算$g$部分的时间复杂度为$O(n^2)$，空间复杂度为$O(n^2)$；计算$f$部分的时间复杂度为$O(n^2)$，空间复杂度为$O(n)$；计算$ans$部分的时间复杂度为$O(n)$，空间复杂度为$O(n)$。

因此，算法总的时间复杂度为$O(n^2)$，空间复杂度$O(n^2)$。

```c++
#include <bits/stdc++.h>

const int max_N = 2000 + 21;

const int mod = 924844033;

int n,k,ans,siz[max_N],fac[max_N];

int f[max_N],g[max_N][max_N][4];

int getG(int i,int j){
	return (g[i][j][0]+g[i][j][2])%mod;
}

int main(){
	scanf("%d%d",&n,&k);
	for(int i=0;i<n;++i)++siz[i%k];
	g[1][0][0]=1;
	g[1][1][1]=1;
	for(int i=2;i<=n;++i)
		for(int j=0;j<=i;++j){
			g[i][j][0]=(g[i-1][j][0]+g[i-1][j][2])%mod;
			g[i][j][2]=(g[i-1][j][1]+g[i-1][j][3])%mod;
			if(!j)continue;
			g[i][j][0]=(g[i][j][0]+g[i-1][j-1][0])%mod;
			g[i][j][1]=(g[i-1][j-1][0]+g[i-1][j-1][2])%mod;
			g[i][j][2]=(g[i][j][2]+g[i-1][j-1][1])%mod;
			g[i][j][3]=(g[i-1][j-1][1]+g[i-1][j-1][3])%mod;
		}
	f[0]=1;
	for(int x=0;x<k;++x)
		for(int i=n;i;--i)
			for(int j=1;j<=i&&j<=siz[x];++j){
				f[i] = (f[i] + 1ll*f[i-j]*getG(siz[x],j)) % mod;
			}
	fac[0]=1;
	for(int i=1;i<=n;++i)fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=0;i<=n;++i){
		int tmp=1ll*f[i]*fac[n-i]%mod;
		if(i&1)ans=(ans-tmp+mod)%mod;
		else ans=(ans+tmp)%mod;
	}
	printf("%d\n",ans);
	return 0;
}
```

## [Leftmost Ball](https://agc002.contest.atcoder.jp/tasks/agc002_f)

**题目大意：**

有$n\le2000$种颜色的球，每种颜色都有$k\le2000$个，现在将它们放在一行任意排列，然后将每种颜色最左边的球染色成$0$号颜色（与$n$种颜色都不同），问最终有多少种不同的局面。

**题解：**

考虑如何一个最终局面是否合法。最终局面合法，当且仅当，将出现的颜色按除了$0$号颜色之外的每种颜色最左边的球的顺序重新编号，第$i$种颜色的球左边至少有$i$个白球。

因此可以用$f[i][j]$表示仅考虑有$i$个$0$号球，$j$种不同颜色的球的不同局面数量，则答案为$f[n][n]\times n!$。

显然$f[0][0]=1$，$f[i][j]$则需要考虑当前最左边的球放$0$号球还是放$j$种颜色中编号最小的颜色的球。

- 如果放$0$号球（要求$i>0$），则有$f[i-1][j]$种方案；

- 如果不放$0$号球（要求$j>i$），则需要先将该种颜色的其余$k-2$个球的位置决定好，然后转化为子问题$f[i][j-1]$，共$\displaystyle\binom{i+j(k-1)-1}{k-2}\times f[i][j-1]$种方案；

时空复杂度$O(n(n+k))$，注意要特判$k=1$，此时显然只有一种方案。

```c++
#include <bits/stdc++.h>

const int max_N = 2e3 + 21;

const int mod = 1e9 + 7;

int n,k,f[max_N][max_N];

int fac[max_N*max_N],_fac[max_N*max_N],inv[max_N*max_N];

inline void init(int n){
	inv[1]=1;
	for(int i=2;i<=n;++i){
		inv[i]=1ll*(mod/i)*inv[mod%i]%mod;
		if(inv[i])inv[i]=mod-inv[i];
	}
	fac[0]=_fac[0]=1;
	for(int i=1;i<=n;++i){
		fac[i]=1ll*fac[i-1]*i%mod;
		_fac[i]=1ll*_fac[i-1]*inv[i]%mod;
	}
}

inline int C(int n,int m){
	return 1ll*fac[n]*_fac[m]%mod*_fac[n-m]%mod;
}

int calc(int i,int j){
	if(~f[i][j])return f[i][j];
	int&res=f[i][j];
	res=0;
	if(i)res=calc(i-1,j);
	if(j>i)
		res=(res+1ll*C(i+j*(k-1)-1,k-2)*calc(i,j-1))%mod;
	return res;
}

int main(){
	scanf("%d%d",&n,&k);
	if(k==1)return puts("1"),0;
	init(n*k);
	for(int i=0;i<=n;++i)
		for(int j=0;j<=n;++j)
			f[i][j]=-1;
	f[0][0]=1;
	int ans=1ll*calc(n,n)*fac[n]%mod;
	printf("%d\n",ans);
	return 0;
}
```