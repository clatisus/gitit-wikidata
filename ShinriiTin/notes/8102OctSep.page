# 数据结构

## cf1017G

[portal](https://codeforces.com/contest/1017/problem/G)

$n\le10^5$个点的树，以$1$为根，一开始每个点都是白色，$q\le10^5$次操作，操作有3种：

- 从点$v$开始，如果$v$为白色，将$v$变为黑色，否则对于$v$的所有儿子递归地执行这一操作
- 将点$v$所在子树全部变为白色
- 询问点$v$当前的颜色

将询问分块，每块的关键点建出虚树，边上记录白点个数，则对于关键点暴力做操作即可。

维护$lazy[u]$为从$u$往下要染黑的距离，当一条边的白点都被染黑后递归到下面的关键点，清空操作清空$lazy[u]$并将白点个数改为原树中缩掉的节点个数。

每块询问做完后，再将非关键点的颜色修改正确，对于被清空过的点要先修改改为白色再判断是否可以被染黑。

复杂度$O(n\sqrt{n})$.

[Code](https://codeforces.com/contest/1017/submission/42310637)

## gym100551A

发现自己15年交了一道gym没加文件输入输出tle的代码，加上就过了。

[portal](https://codeforces.com/gym/100551/problem/A)

无向图，加边，删边，询问连通块数量。

按边的删除时间维护最大生成树，`lct`，复杂度$O(n\log{n})$.

[Code](https://codeforces.com/gym/100551/submission/42311932)

## 51nod 1981

[portal](https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1981)

$n\le65536$个`set`，$q\le65536$次操作，要么给区间$[L,R]$的`set`都`insert`一个$0\le c\le30000$，要么询问区间`[L,R]`的`set`合并成一个`set`后第`k`小，非法输出`-1`.

用线段树套`bitset`，标记永久化一下，询问时二分一下，注意$k=0$也是非法。

时间复杂度$O(n\log{n}\cdot \frac{q}{32})$，空间复杂度$O(n\cdot\frac{q}{32})$.

```c++
#include <bits/stdc++.h>

inline void read(int &x) {
    char c;
    while (!isdigit(c = getchar()));
    x = c - '0';
    while (isdigit(c = getchar())) {
        (x *= 10) += c - '0';
    }
}

#define ls(x) ((x) << 1)
#define rs(x) (ls(x) | 1)
#define mid ((l + r) >> 1)
#define lch ls(x), l, mid
#define rch rs(x), mid + 1, r

const int max_N = 65536 + 21;
const int max_M = 10001;

using data = std::bitset<max_M>;

int n, q, ql, qr, qt, opt;

data seg[max_N << 1], lazy[max_N << 1], qa;

void modify(int x, int l, int r) {
    seg[x].set(qt);
    if (ql <= l && r <= qr) {
        lazy[x].set(qt);
    } else {
        if (ql <= mid) modify(lch);
        if (qr > mid)  modify(rch);
    }
}

void query(int x, int l, int r) {
    qa |= lazy[x];
    if (ql <= l && r <= qr) {
        qa |= seg[x];
    } else {
        if (ql <= mid) query(lch);
        if (qr > mid)  query(rch);
    }
}

int main() {
    read(n), read(q);
    while (q--) {
        read(opt), read(ql), read(qr), read(qt);
        if (opt == 1) {
            modify(1, 1, n);
        } else {
            qa.reset();
            query(1, 1, n);
            int sum = qa.count();
            if (!qt || qt > sum) {
                puts("-1");
            } else {
                int lo = 0, hi = 10000;
                while (lo < hi) {
                    int mi = (lo + hi) >> 1;
                    int cur = sum - (qa >> (mi + 1)).count();
                    if (cur >= qt) {
                        hi = mi;
                    } else {
                        lo = mi + 1;
                    }
                }
                printf("%d\n", lo);
            }
        }
    }
    return 0;
}
```


