# DP套DP学习笔记

> 通过外层的DP来计算使得内层的DP方程（子DP）为给定值的输入方案数

## 例题

### [HDU 4899 Hero meet devil](http://acm.hdu.edu.cn/showproblem.php?pid=4899)

**题目大意**：给出一个只由$ACGT$组成的字符串$S$，($|S|\le15$)，对于每个$0\le i \le|S|$，求有多少个不同的只由$ACGT$组成的长度为$1\le m\le1000$的字符串$T$，使得$LCS(S,T)=i$。

**题解**：

子DP的方程为$f[i][j] = \begin{cases} f[i-1][j-1]+1 &, S[i]=T[j]\\ \max(f[i-1][j],f[i][j-1]) &,S[i]\not=T[j] \end{cases}$

 $f[i][j]$与$f[i+1][j]$至多只会相差$1$，将第一维状态差分一下，得到一个长度为$|S|$的01串，这个01串记录了子DP中$f[0,\cdots,|S|][j]$的所有状态，因此，我们可以通过这个01串来进行外层的DP。

设计外层DP为$g[i][set]$表示考虑$T$的前$i$个位置，$f[0,\cdots,|S|][i]$的状态为$set$的方案数。

我们可以预处理出子DP每个状态对应每种转移后能得到的状态值（建出关于子DP的自动机），然后外层DP的转移就是利用这些预处理的信息来实现的。

子DP的状态数为$2^{|S|}$，转移数为$4\times2^{|S|}$，令$n=|S|$，则建立子DP的自动机的时间复杂度为$O(4\times2^n\times n)$，空间复杂度为$O(4\times2^n)$。

外层DP的状态数为$m\times2^n$，转移数为$4\times2^n\times m$，时间复杂度为$O(4\times2^n\times m)$，采用滚动数组，空间复杂度为$O(2^n)$。

因此总的时间复杂度为$4\times2^n\times(n+m)$，空间复杂度为$O(4\times2^n)$。

```c++
#include <bits/stdc++.h>

const int max_S=1<<15,mod=1e9+7;

const char C[5]="ACGT";

struct DFA{
	int n,s,trans[max_S][4];	
	inline void build(char*S,int n){
		this->n=n,s=1<<n;
		int d[20]={0},g[20]={0};//f[i][j-1],f[i][j]
		for(int set=0;set<s;++set){
			for(int i=0;i<n;++i)d[i+1]=d[i]+(set>>i&1);
			for(int k=0;k<4;++k){
				for(int j=1;j<=n;++j){
					if(C[k]==S[j])g[j]=d[j-1]+1;
					else g[j]=std::max(d[j],g[j-1]);
				}
				trans[set][k]=0;
				for(int j=0;j<n;++j)if(g[j+1]>g[j])trans[set][k]|=1<<j;
			}
		}
	}
}F;

int T,n,m,bitcnt[max_S],g[2][max_S],ans[20];

char s[20];

int main(){
	for(int i=1;i<max_S;++i){
		bitcnt[i]=bitcnt[i-(i&-i)]+1;
	}
	scanf("%d",&T);
	while(T--){
		scanf("%s%d",s+1,&m);
		F.build(s,n=strlen(s+1));
		int cur=0,maxs=1<<n;
		memset(g[0],0,sizeof(int)*maxs);
		g[0][0]=1;
		while(m--){
			cur^=1;
			memset(g[cur],0,sizeof(int)*maxs);
			for(int i=0,j,tmp;i<maxs;++i){
				if(!(tmp=g[cur^1][i]))continue;
				for(int k=0;k<4;++k){
					j=F.trans[i][k];
					g[cur][j]=(g[cur][j]+tmp)%mod;
				}
			}
		}
		for(int i=0;i<=n;++i)ans[i]=0;
		for(int i=0;i<maxs;++i){
			int&res=ans[bitcnt[i]];
			res=(res+g[cur][i])%mod;
		}
		for(int i=0;i<=n;++i)printf("%d\n",ans[i]);
	}
	return 0;
}
```

