# General

[题目下载](/bcpc-2018-onsite.pdf)

# Solutions

## A. wjj 的分手厨房

- 出题人 MKibera

把所有出现的菜相加即可。

## B. zzh 与子序列

- 出题人 zhongzihao

这道题可以采用数位 `dp` 的思想来解决。

设我们所求的子序列为 $t$，设当前已经知道了 $t$ 的前 $j$ 位，即 $t_{1}\cdots t_{j}$ 已知。此时我们只考虑 $s$ 中所有以 $t_{1},\cdots t_{j}$ 为前缀的子序列，设 $t$ 是其中第 $k_{j}$ 小的。

考虑求 $t_{j+1}$ 及 $k_{j+1}$。我们依次枚举 $c=\varepsilon,1,2,\cdots,\Sigma$。如果以 $t_{1},\cdots t_{j}c$ 为前缀的子序列数量小于 $k_{j}$，那么显然 $t_{j+1}$ 要大于 $c$，我们从 $k_{j}$ 中减去这个数量；否则 $t_{j+1}$ 就是我们枚举的 $c$，$k_{j+1}$ 就是减完后剩余的 $k_{j}$。如果 $t_{j+1}=\varepsilon$，那么 $t_{1}\cdots t_{j}$ 就是答案。

考虑上一段提到的“以 $t_{1},\cdots t_{j}c$ 为前缀的子序列数量”如何求出。假设我们知道这样一个 `dp` 数组（之后再考虑如何转移）：`dp[i][j]` 表示 $t$ 的第 $j$ 位在 $s$ 的第 $i$ 位取到的方案数。那么这个数量即为 $\sum_{i=1}^{n}[s_{i}=c]2^{n-i}\sum_{u=1}^{i-1}dp[u][j]$，内层的求和可以用前缀和来维护。因而对于所有的 $c$ 我们很容易用总共 $\mathcal{O}(n)$ 的时间求出上述数量。

现在我们知道了 $t_{j+1}$，那么 $dp$ 的转移就比较简单了，我们有 $dp[i][j+1]=[s_{i}=t_{j+1}]\sum_{u=1}^{i-1}dp[u][j]$。

时间复杂度 $\mathcal{O}(n^{2})$，空间复杂度 $\mathcal{O}(n)$（`dp` 第二维可以滚动）。

**tips**：时间复杂度之所以和 $\Sigma$ 无关，是因为我们可以将输入的字符离散化，这样相当于 $\Sigma=\mathcal{O}(n)$。也就是说 $\Sigma$ 可以出得更大。但是善良的出题人觉得这样没什么意思，于是 $\Sigma$ 就小于等于 $5000$ 了。

这道题实现的时候，需要准确地处理两个数相加或相乘超过 `long long` 范围的情况。出题人曾经只会转成 `double` 计算后和 `INF` 取 `min`，但是比较麻烦，这里提供一个比较优雅的实现方法（不知道大家是否有同样的问题）：

```c++
ll mult(ll a, ll b){
    if (!a || !b) return 0;
    return a <= INF / b ? a * b : INF;
}
```

## C. 未闻题名

- 出题人 Chielo
- 题目定位：推一推的签到题

数据范围看起来很大，所以多半是个 $\mathcal{O}(n)$ 的。

先考虑 DP，记以前 $i$ 个元素最多能组成 $b_i$ 个题目。有：

$$b_i = \max\limits_{j < i} b_j + [\sum_{k=j+1}^i {a_i} > m]$$

其中 $[\sum_{k=j+1}^i {a_i} > m]$，
即从 $j+1$ 到 $i$ 的 $a_i$ 部分和如果超过 $m$，就为 $1$，否则为 $0$。

容易发现转移的 $j$ 没有限制，所以 $b_i > b_j$ 当 $j < i$，即 $b_i$ 不严格单调递增。
所以对于后面的布尔表达式为 $0$ 或 $1$ 的情况，可以直接取各自中 $j$ 最大的作为转移。
即是说，假设对于 $i$，求出来最大的 $j$，使得 $\sum_{k=j+1}^i {a_i} > m$ 成立，
有

$$b_i = \max(b_{i-1}, b_j + 1)$$

可以发现这样的决策等价于每次找一个尽可能短的、不交叉的、大于 $m$ 的段，
插入到之前最好的答案后面。

可以直接贪心，维护当前位置作为结尾，
和之前选取过的段不相交的、最大的连续段的和；
一旦这个和超过 $m$ 就可以加入到答案中。
能够通过这个方式构造得到的答案，不会劣于其他方式得到的答案。

时间复杂度 $\mathcal{O}(n)$。

## D. 区间 mex

- 出题人 coldwater
- 题目定位：very hard

## E. 啷个的 Scramble String

- 出题人

## F. 构造题

- 出题人 coldwater
- 题目定位：very easy

## G. 进化吧亚古兽！！！

- 出题人


### 暴力 --- $O(nm)$

每次询问直接进行树上$\text{dp}$，状态 $f _ i$ 表示以 $i$ 号节点为根的子树节点个数（包括根节点），状态 $g _ i$ 表示该子树中，所有点权为当次询问 $V$ 倍数的节点到 $i$ 号节点的距离之和。

设某个节点为根 $\text{dfs}$ 整棵树（譬如我们设 $1$ 号节点为根, $\text{dfs(1)}$ ），对于每个节点 $i$ 依次遍历其子树，初始化 $f _ i=(v _ i\ \text{mod}\ V==0)$，$g _ i=0$ 。令 $j$ 号点为 $i$ 号点的下一层子节点（儿子节点），则先调用函数 $\text{dfs(j)}$ 获取 $f _ j$ 和 $g _ j$，随后用 $ f _ i \times (\text{dist(i, j)} \times f _ j + g _ j) + g _ i \times f _ j$ 的结果更新答案，其中 $\text{dist(i, j)}$ 表示树边 $<i,j>$ 的权值。

然后更新 $f_i=f_i+f_j$，$g_i=g_i+f_j\times \text{dist(i,j)}+g_j$，再继续遍历 $i$ 号节点的下一个儿子节点。

每一次 $\text{dp}$ 的时间复杂度为 $O(n)$ ，故总时间复杂度为 $O(nm)$

### 虚树 --- $O(n \log^2 n)$

我们可以发现，每次询问只需处理所有点权为 $V$ 若干倍的节点，故可以考虑构建虚树进而降低整体时间复杂度。

预处理出每个节点在原树中到树根的值 $dist _ i$ 用于计算虚树中新树边的权值，每次直接获取点权为 $k \times V$ 的节点，然后按照 $\text{dfs}$ 序进行排序进而构建虚树，随后在树上进行同样的 $\text{dp}$。

节点数总和为 $n \log n$，每次询问需要进行一次 $\text{sort}$ ，复杂度为 $O(n \log ^2 n)$ ；使用倍增获取 $lca$ 的单次复杂度为$O(\log n)$，构造虚树总复杂度为 $O(n \log^2 n)$。故总复杂度为 $O(n \log^2 n)$ 。

题目最开始的标算是这样的，但是***佬教头***表示完全可以一个 $\log$ 完成，于是有了下面的优化部分。原本出题人打算卡掉 $\log^2$ 的丑陋做法，但是正义的伙伴们及时制止了这邪恶的行为，并为了阻止卡常的可能进而在比赛时将时限扩大到 $4s$ ，只要常数不是特别大还是能过的，可惜的是似乎没有同学来秒了这道模板题 :(

**醒目：墙裂建议阅读以下部分并尝试编写代码**

### 优化 --- $O(n \log n)$

首先进行一次 $\text{dfs}$ ，得到各节点 $\text{dfs}$ 序，并获取 $\text{dfs}$ 序列，注意，每个点在初次访问、每个子节点遍历结束时都要加入 $\text{dfs}$ 序列。接着在 $O(n \log n)$ 内获取各点权的因子集合 $S _ v$ ，随后将各节点按 $\text{dfs}$ 排序。对每个节点 $i$ ，访问其因子集合 $S _ {v _ i}$ ，对于因子 $v$ ，将节点 $i$ 添加至集合 $P _ v$ 末尾即可。初始化时间总复杂度为 $O(n \log n)$ 。

随后每次询问 $V$，将集合 $P _ v$ 中节点依次取出构建虚树，并用 $\text{ST}$ 表 $O(1)$ 查询 $\text{dfs}$ 序列中 $i$ 号节点与 $j$ 号节点分别首次出现的位置组成的区间中深度最小的节点，即为所求 $\text{LCA}$ ，进而将构建虚树的总复杂度优化至 $O( n \log n)$ 。

由于我们的 $\text{dp}$ 是线性的，故 $\text{dp}$ 总复杂度为 $O(n \log n)$ 。

综上，我们将算法时间复杂度降至 $O(n \log n)$ 。
