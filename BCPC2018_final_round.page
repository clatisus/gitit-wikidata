# General

[题目下载](/bcpc-2018-onsite.pdf)

# Solutions

## A. wjj 的分手厨房

- 出题人 MKibera

把所有出现的菜相加即可。

## B. zzh 与子序列

- 出题人 zhongzihao

这道题可以采用数位 `dp` 的思想来解决。

设我们所求的子序列为 $t$，设当前已经知道了 $t$ 的前 $j$ 位，即 $t_{1}\cdots t_{j}$ 已知。此时我们只考虑 $s$ 中所有以 $t_{1},\cdots t_{j}$ 为前缀的子序列，设 $t$ 是其中第 $k_{j}$ 小的。

考虑求 $t_{j+1}$ 及 $k_{j+1}$。我们依次枚举 $c=\varepsilon,1,2,\cdots,\Sigma$。如果以 $t_{1},\cdots t_{j}c$ 为前缀的子序列数量小于 $k_{j}$，那么显然 $t_{j+1}$ 要大于 $c$，我们从 $k_{j}$ 中减去这个数量；否则 $t_{j+1}$ 就是我们枚举的 $c$，$k_{j+1}$ 就是减完后剩余的 $k_{j}$。如果 $t_{j+1}=\varepsilon$，那么 $t_{1}\cdots t_{j}$ 就是答案。

考虑上一段提到的“以 $t_{1},\cdots t_{j}c$ 为前缀的子序列数量”如何求出。假设我们知道这样一个 `dp` 数组（之后再考虑如何转移）：`dp[i][j]` 表示 $t$ 的第 $j$ 位在 $s$ 的第 $i$ 位取到的方案数。那么这个数量即为 $\sum_{i=1}^{n}[s_{i}=c]2^{n-i}\sum_{u=1}^{i-1}dp[u][j]$，内层的求和可以用前缀和来维护。因而对于所有的 $c$ 我们很容易用总共 $\mathcal{O}(n)$ 的时间求出上述数量。

现在我们知道了 $t_{j+1}$，那么 $dp$ 的转移就比较简单了，我们有 $dp[i][j+1]=[s_{i}=t_{j+1}]\sum_{u=1}^{i-1}dp[u][j]$。

时间复杂度 $\mathcal{O}(n^{2})$，空间复杂度 $\mathcal{O}(n)$（`dp` 第二维可以滚动）。

**tips**：时间复杂度之所以和 $\Sigma$ 无关，是因为我们可以将输入的字符离散化，这样相当于 $\Sigma=\mathcal{O}(n)$。也就是说 $\Sigma$ 可以出得更大。但是善良的出题人觉得这样没什么意思，于是 $\Sigma$ 就小于等于 $5000$ 了。

这道题实现的时候，需要准确地处理两个数相加或相乘超过 `long long` 范围的情况。出题人曾经只会转成 `double` 计算后和 `INF` 取 `min`，但是比较麻烦，这里提供一个比较优雅的实现方法（不知道大家是否有同样的问题）：

```c++
ll mult(ll a, ll b){
    if (!a || !b) return 0;
    return a <= INF / b ? a * b : INF;
}
```

## C. 未闻题名

- 出题人 Chielo
- 题目定位：推一推的签到题

数据范围看起来很大，所以多半是个 $\mathcal{O}(n)$ 的。

先考虑 DP，记以前 $i$ 个元素最多能组成 $b_i$ 个题目。有：

$$b_i = \max\limits_{j < i} b_j + [\sum_{k=j+1}^i {a_i} > m]$$

其中 $[\sum_{k=j+1}^i {a_i} > m]$，
即从 $j+1$ 到 $i$ 的 $a_i$ 部分和如果超过 $m$，就为 $1$，否则为 $0$。

容易发现转移的 $j$ 没有限制，所以 $b_i > b_j$ 当 $j < i$，即 $b_i$ 不严格单调递增。
所以对于后面的布尔表达式为 $0$ 或 $1$ 的情况，可以直接取各自中 $j$ 最大的作为转移。
即是说，假设对于 $i$，求出来最大的 $j$，使得 $\sum_{k=j+1}^i {a_i} > m$ 成立，
有

$$b_i = \max(b_{i-1}, b_j + 1)$$

可以发现这样的决策等价于每次找一个尽可能短的、不交叉的、大于 $m$ 的段，
插入到之前最好的答案后面。

可以直接贪心，维护当前位置作为结尾，
和之前选取过的段不相交的、最大的连续段的和；
一旦这个和超过 $m$ 就可以加入到答案中。
能够通过这个方式构造得到的答案，不会劣于其他方式得到的答案。

时间复杂度 $\mathcal{O}(n)$。

## D. 区间 mex

- 出题人 coldwater
- 题目定位：very hard

## E. 啷个的 Scramble String

- 出题人 braveTester


### 暴力

对于给定的字符串 $x$ 和 $y$，由于题意，可知 $y$ 中字符和 $x$ 中字符的一一对应关系。$O(|y|)$ 扫描 $y$，如果 $y[i]$ 和 $y[i + 1]$ 在 $x$ 中对应的字符位置相邻，即存在 $j$ 使得（$x[j] = y[i]$ 且 $x[j + 1] = y[i + 1]$），或者（ $x[j + 1] = y[i]$ 且 $x[j] = y[i + 1]$），则将两字符合并，可得到新的字符串 $x'$ 和 $y'$。重复前述过程，直到不能进行。如果此时 $x$ 只含一个字符，则原始两个字符串互为 Scramble 字符串，否则不是。暴力复杂度 $O(|x|^2)$ 。

### 优化

注意到合并之后，会出现至多两个新的位置需要检查，而合并操作最多进行 $|x| - 1$ 次，因此至多需要检查 $|x| - 1 + 2(|x| - 1) = 3(|x| - 1)$ 次。如果用区间表示合并后的字符，则检查和合并都可以做到 $O(1)$，因此总复杂度为 $O(|x|)$。

### 正确性证明

上述算法找到的解的正确性是显然的，因此只有可能存在情况上述算法找不到解。这里有两种情况，第一种为 $x$ 和 $y$ 互为 Scramble 字符串，但是算法进行不下去，另外一种是 $x$ 和 $y$ 互为 Scramble 字符串，但是经过一轮迭代之后，$x'$ 和 $y'​$ 不互为 Scramble 字符串。下将说明这两种情况都是不可能的。

#### 若有解，算法必定可以进行

对于第一种情况，因为可行解的树中必然存在一个节点上挂了两个叶子，因此 $y$ 中必有一个位置使得算法可以进行下去。

#### 若初始有解，则经算法进行一轮迭代后，依然有解

先对下述证明过程中的记号做些说明：

1. 令可行解树为 Scramble 字符串定义中所定义的树状结构，满足其叶子依 DFS 序排列得到 $y$，其余节点对应于 $x$ 中的一个连续子串。可行解树不一定唯一。
2. 对于可行解树上的任一节点 $\text{node}$，$\text{node}$ 既可以指树上的节点，也可以指该节点对应于 $x$ 中的连续字串，读者可从上下文推断其含义。

下证如果 $x$ 和 $y$ 互为 Scramble 字符串，则 $x'$ 和 $y'$ 也互为 Scramble 字符串。算法选择合并的两个字符，对应于可行解的树上的两个叶子 $u$ 和 $v$，且两个叶子在解树的 DFS 序上是相邻的两个叶子（中间可能有其它非叶节点，但不可能有叶节点）。考虑 $u$、$v$ 和 $\text{LCA}(u, v)$ 的关系，必有 $u$ 是 $\text{LCA}(u, v)$ 左儿子 $p$ 的最右子孙，$v$ 是 $\text{LCA}(u, v)$ 右儿子 $q$ 的最左子孙。因为 $u$ 和 $v$ 在 $x$ 中相邻，

- 如果 $pq$ 是 $x$ 的连续子串，则 $u$ 为 $p$ 的最右字符，且 $v$ 为 $q$ 的最左字符，或者
- 如果 $qp$ 是 $x$ 的连续子串，则 $u$ 为 $p$ 的最左字符，且 $v$ 为 $q$ 的最右字符。

考虑第一种情况。因为 $u$ 是 $p$ 的最右字符，且 $u$ 为 $p$ 的最右子孙，因此 $p$ 至 $u$ 路径上的所有节点（含 $p$，不含 $u$）的儿子都是没有交换过的，因为如果交换过，则 $u$ 不可能为 $p$ 的最右子孙。而这样的树可以通过旋转操作改变形态而不改变对应字符串，如下图所示：

![不交换旋转图](/public/不交换旋转图.png)

因此可以将 $u$ 旋转为 $p$ 的右儿子。同理，可以将 $q$ 旋转为 $v$ 的左儿子。

之后经如下图的变换即可将 $u$、$v$ 成为兄弟：

![变换为相邻的步骤](/public/变换为相邻的步骤.PNG)

而将 $uv$ 视为一个字符后，变换得到的树即为 $x'$ 变换至 $y'$ 的一个解，因此 $x'$ 和 $y'$ 互为 Scramble 字符串。

对于第二种情况，类似可得。具体来说，$p$ 至 $u$ 路径上所有节点的儿子都是被交换过的，而满足该种情况的树也可以通过如下形式变换形态而不改变对应字符串：

![交换旋转图](/public/交换旋转图.png)

因此可以将 $u$ 旋转为 $p$ 的右儿子，同理，可以将 $v$ 旋转为 $q$ 的左儿子。之后经下图变换即可令 $u$、$v$ 成为兄弟：

![变换为相邻的步骤-2](/public/变换为相邻的步骤-2.PNG)

综上所述，如果 $x$ 和 $y$ 互为 Scramble 字符串，则 $x'$ 和 $y'$ 互为 Scramble 字符串。

**注**：上述证明过程中省略了对于退化情况的说明，即 $u = p$ 或 $v = q$ 的情况。而对于这些情况，不难以类似过程得到证明。

#### 结论

由此，算法正确性得证。

## F. 构造题

- 出题人 coldwater
- 题目定位：very easy

显然 $n=2$ 的时候无解。$n > 2$ 时，我们选择一点作为圆心，然后不断的在圆周上选择两个点，满足它们与圆心构成等边三角形，显然满足题目条件，这样奇数的情况就做完了。对于偶数的情况，我们需要将两个等边三角形的一条边重合即可。

## G. 进化吧亚古兽！！！

- 出题人 Immortal.S


### 暴力 --- $O(nm)$

每次询问直接进行树上$\text{dp}$，状态 $f _ i$ 表示以 $i$ 号节点为根的子树节点个数（包括根节点），状态 $g _ i$ 表示该子树中，所有点权为当次询问 $V$ 倍数的节点到 $i$ 号节点的距离之和。

设某个节点为根 $\text{dfs}$ 整棵树（譬如我们设 $1$ 号节点为根, $\text{dfs(1)}$ ），对于每个节点 $i$ 依次遍历其子树，初始化 $f _ i=(v _ i\ \text{mod}\ V==0)$，$g _ i=0$ 。令 $j$ 号点为 $i$ 号点的下一层子节点（儿子节点），则先调用函数 $\text{dfs(j)}$ 获取 $f_j$ 和 $g_j$，随后用 $f_i \times (\text{dist(i, j)} \times f_j + g_j) + g_i \times f_j$ 的结果更新答案，其中 $\text{dist(i, j)}$ 表示树边 $<i,j>$ 的权值。

然后更新 $f_i=f_i+f_j$，$g_i=g_i+f_j\times \text{dist(i,j)}+g_j$，再继续遍历 $i$ 号节点的下一个儿子节点。

每一次 $\text{dp}$ 的时间复杂度为 $O(n)$ ，故总时间复杂度为 $O(nm)$

### 虚树 --- $O(n \log^2 n)$

我们可以发现，每次询问只需处理所有点权为 $V$ 若干倍的节点，故可以考虑构建虚树进而降低整体时间复杂度。

预处理出每个节点在原树中到树根的值 $dist _ i$ 用于计算虚树中新树边的权值，每次直接获取点权为 $k \times V$ 的节点，然后按照 $\text{dfs}$ 序进行排序进而构建虚树，随后在树上进行同样的 $\text{dp}$。

节点数总和为 $n \log n$，每次询问需要进行一次 $\text{sort}$ ，复杂度为 $O(n \log ^2 n)$ ；使用倍增获取 $lca$ 的单次复杂度为$O(\log n)$，构造虚树总复杂度为 $O(n \log^2 n)$。故总复杂度为 $O(n \log^2 n)$ 。

题目最开始的标算是这样的，但是***佬教头***表示完全可以一个 $\log$ 完成，于是有了下面的优化部分。原本出题人打算卡掉 $\log^2$ 的丑陋做法，但是正义的伙伴们及时制止了这邪恶的行为，并为了阻止卡常的可能进而在比赛时将时限扩大到 $4s$ ，只要常数不是特别大还是能过的，可惜的是似乎没有同学来秒了这道模板题 :(

**醒目：墙裂建议阅读以下部分并尝试编写代码**

### 优化 --- $O(n \log n)$

首先进行一次 $\text{dfs}$ ，得到各节点 $\text{dfs}$ 序，并获取 $\text{dfs}$ 序列，注意，每个点在初次访问、每个子节点遍历结束时都要加入 $\text{dfs}$ 序列。接着在 $O(n \log n)$ 内获取各点权的因子集合 $S _ v$ ，随后将各节点按 $\text{dfs}$ 排序。对每个节点 $i$ ，访问其因子集合 $S _ {v _ i}$ ，对于因子 $v$ ，将节点 $i$ 添加至集合 $P _ v$ 末尾即可。初始化时间总复杂度为 $O(n \log n)$ 。

随后每次询问 $V$，将集合 $P _ v$ 中节点依次取出构建虚树，并用 $\text{ST}$ 表 $O(1)$ 查询 $\text{dfs}$ 序列中 $i$ 号节点与 $j$ 号节点分别首次出现的位置组成的区间中深度最小的节点，即为所求 $\text{LCA}$ ，进而将构建虚树的总复杂度优化至 $O( n \log n)$ 。

由于我们的 $\text{dp}$ 是线性的，故 $\text{dp}$ 总复杂度为 $O(n \log n)$ 。

综上，我们将算法时间复杂度降至 $O(n \log n)$ 。

## H. Ange 的线性代数题

- 出题人 Prime21

### H(n)


$$ H(n) = \sum_{d | n} \mu( \frac{n}{d} ) ( 2 ^{ \sigma_0 (d) - 1} ) $$

其中$\mu(n)$ 是莫比乌斯函数，$\sigma_0(n)$ 表示$n$的约束个数。

一个简单的证明，尝试莫比乌斯反演
$$ G(n) = \sum_{d | n} H(d) $$


G(n)表示有多少个正整数集合使得集合的最小公倍数被$n$整除，可以显然的发现$G(n) = 2^{\sigma_0(n) - 1}$，这是因为，对于$n$的每一个因子可以出现或者不出现在这个集合中，且取除空集的情形。

如果想看更加详细的相关内容可以参考[oeis A076078][1]

### L(n)
L(n)比较好表示，可以利用$n$以内的所有质因子的幂次表示，暂记
$L(n) = [1,2,\cdots,n] = \prod_{i=1}^{m} {p_i}^{q_i}$

并且注意到莫比乌斯函数存在平方因子时为零

故 $$H(L(n))  = \sum_{d_i = 0,1} (-1) ^ { \sum_{i} d_i } 2 ^{\prod_{i} (q_i - d_i+1)}$$

注意到这里的模数是质数，且$\gcd(2,10^9+7) = 1$，故可以直接用快速幂完成相关任务。

### 一些后续可能的问题

1. 如果模数不是质数，注意到这样的组合在范围内是有限的，dfs后可知仅有6000种不到，可以直接dfs所有情况计数

2. 如果直接考虑到$H(n)$的性质，上述的求和过程，也可以套用一些数论相关常用dp的思路解决

  [1]: https://oeis.org/A076078

## I. 击鼓传花

- 出题人 Immortal.S

题目即求 $(x_i+a*t_i)\bmod n_i$ 的所有结果。

令 $\text{gys}=\text{gcd}(t_i, n_i)$ ，可证:

$x_i+a_0*t_i=y_i+b_0*n_i$ 等价于 $x_i+a_1*\text{gys}=y_i+b_1*n_i$

故只需计算 $(1+n_i-x_i)\bmod \text{gys}$ 的结果，若为 $0$ 则说明 $1$ 号会被抽中，否则不会。
