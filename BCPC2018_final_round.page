# General

[题目下载](/bcpc-2018-onsite.pdf)

# Solutions

## A. wjj 的分手厨房

把所有出现的菜相加即可。

## B. zzh 与子序列

这道题可以采用数位 `dp` 的思想来解决。

设我们所求的子序列为 $t$，设当前已经知道了 $t$ 的前 $j$ 位，即 $t_{1}\cdots t_{j}$ 已知。此时我们只考虑 $s$ 中所有以 $t_{1},\cdots t_{j}$ 为前缀的子序列，设 $t$ 是其中第 $k_{j}$ 小的。

考虑求 $t_{j+1}$ 及 $k_{j+1}$。我们依次枚举 $c=\varepsilon,1,2,\cdots,\Sigma$。如果以 $t_{1},\cdots t_{j}c$ 为前缀的子序列数量小于 $k_{j}$，那么显然 $t_{j+1}$ 要大于 $c$，我们从 $k_{j}$ 中减去这个数量；否则 $t_{j+1}$ 就是我们枚举的 $c$，$k_{j+1}$ 就是减完后剩余的 $k_{j}$。如果 $t_{j+1}=\varepsilon$，那么 $t_{1}\cdots t_{j}$ 就是答案。

考虑上一段提到的“以 $t_{1},\cdots t_{j}c$ 为前缀的子序列数量”如何求出。假设我们知道这样一个 `dp` 数组（之后再考虑如何转移）：`dp[i][j]` 表示 $t$ 的第 $j$ 位在 $s$ 的第 $i$ 位取到的方案数。那么这个数量即为 $\sum_{i=1}^{n}[s_{i}=c]2^{n-i}\sum_{u=1}^{i-1}dp[u][j]$，内层的求和可以用前缀和来维护。因而对于所有的 $c$ 我们很容易用总共 $\mathcal{O}(n)$ 的时间求出上述数量。

现在我们知道了 $t_{j+1}$，那么 $dp$ 的转移就比较简单了，我们有 $dp[i][j+1]=[s_{i}=t_{j+1}]\sum_{u=1}^{i-1}dp[u][j]$。

时间复杂度 $\mathcal{O}(n^{2})$，空间复杂度 $\mathcal{O}(n)$（`dp` 第二维可以滚动）。

**tips**：时间复杂度之所以和 $\Sigma$ 无关，是因为我们可以将输入的字符离散化，这样相当于 $\Sigma=\mathcal{O}(n)$。也就是说 $\Sigma$ 可以出得更大。但是善良的出题人觉得这样没什么意思，于是 $\Sigma$ 就小于等于 $5000$ 了。

这道题实现的时候，需要准确地处理两个数相加或相乘超过 `long long` 范围的情况。出题人曾经只会转成 `double` 计算后和 `INF` 取 `min`，但是比较麻烦，这里提供一个比较优雅的实现方法（不知道大家是否有同样的问题）：

```c++
ll mult(ll a, ll b){
    if (!a || !b) return 0;
    return a <= INF / b ? a * b : INF;
}
```



