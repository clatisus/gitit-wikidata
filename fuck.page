//
// Created by zzh on 2019/8/10.
//
```c++
#include <bits/stdc++.h>

const int N = 20000010;
typedef long long ll;
const int moder = 998244353;
const int M = 10000010;

int fac[N], inv[N], invf[N];
int dp[M], pre[M];

int comb(ll n, ll m){
    if (n < m || m < 0){
        return 0;
    }
    return 1ll * fac[n] * invf[m] % moder * invf[n - m] % moder;
}

struct poly{
    int coe;
    ll up, down;
};

struct event{
    int t, p;

    bool operator <(const event &e)const{
        return t < e.t;
    }
};

int getpos(std::vector <poly> &vec, int pos){
    int ans = 0;
    for (auto u : vec){
        ans = (ans + 1ll * u.coe * comb(pos - u.up + u.down - 1, u.down - 1)) % moder;
    }
    return ans;
}

int main(){
    fac[0] = invf[0] = 1;
    for (int i = 1; i < N; ++ i){
        fac[i] = 1ll * i * fac[i - 1] % moder;
        inv[i] = i == 1 ? 1 : moder - 1ll * (moder / i) * inv[moder % i] % moder;
        invf[i] = 1ll * invf[i - 1] * inv[i] % moder;
    }
    std::vector <poly> vec = {{1, 0, 0}};
    int l, d, m;
    scanf("%d%d%d", &l, &d, &m);
    dp[0] = pre[0] = 1;
    for (int i = 1; i < M; ++ i){
        dp[i] = i - d >= 0 ? pre[i - d] : 0;
        pre[i] = pre[i - 1] + dp[i];
        pre[i] -= pre[i] >= moder ? moder : 0;
    }
    std::vector <event> evec(m);
    for (int i = 0; i < m; ++ i){
        scanf("%d%d", &evec[i].t, &evec[i].p);
    }
    std::sort(evec.begin(), evec.end());
    int cur = 0, pos = 0;
    int ans = dp[l];
    while (pos < m){
        int diff = evec[pos].t - cur;
        cur += diff;
        for (auto &u : vec){
            u.up += 1ll * diff * d;
            u.down += diff;
        }
        while (pos < m && evec[pos].t == cur){
            int coe = -getpos(vec, evec[pos].p);
            vec.push_back({coe, evec[pos].p, 0});
            ans = (ans + 1ll * coe * dp[l - evec[pos].p]) % moder;
            ++ pos;
        }
    }
    ans += ans < 0 ? moder : 0;
    printf("%d\n", ans);
    return 0;
}

```