```c++
//
// Created by zzh on 2019/8/10.
//

#include <bits/stdc++.h>

using LL = long long;

const int max_N = (int)3e5 + 21;

int n;

namespace SegmentTree {
const int seg_N = max_N * 12;

int tot, ls[max_N], rs[max_N], cnt[seg_N];

LL sum[max_N];

std::vector<int> node;

int new_node() {
    int x;
    if (node.empty()) {
        x = ++tot;
    } else {
        x = node.back();
        node.pop_back();
    }
    sum[x] = ls[x] = rs[x] = cnt[x] = 0;
}

#define mid ((l + r) >> 1)

void modify(int ql, int qr, int &x, int l = 1, int r = n) {
    if (!x) x = new_node();
    if (ql <= l && r <= qr) {
        ++cnt[x];
        sum[x] += qr - ql + 1;
    } else {
        if (ql <= mid) modify(ql, qr, ls[x], l, mid);
        if (qr >  mid) modify(ql, qr, rs[x], mid + 1, r);
        sum[x] = sum[ls[x]] + sum[rs[x]] + 1LL * cnt[x] * (qr - ql + 1);
    }
}

LL query(int ql, int qr, int x, int l = 1, int r = n) {
    if (!x) return 0;
    if (ql <= l && r <= qr) {
        return sum[x];
    } else {
        LL ret = 0;
        if (ql <= mid) ret += query(ql, qr, ls[x], l, mid);
        if (qr >  mid) ret += query(ql, qr, rs[x], mid + 1, r);
        int L = std::max(ql, l);
        int R = std::min(qr, r);
        ret += 1LL * cnt[x] * (R - L + 1);
        return ret;
    }
}

void rec(int x) {
    if (!x) return;
    node.push_back(x);
    rec(ls[x]);
    rec(rs[x]);
}
}

int m, q, p[max_N], l[max_N], r[max_N], ql[max_N], qr[max_N];

LL ret[max_N];

std::vector<int> vec[max_N], qy[max_N];

int siz[max_N], max[max_N];

void dfs1(int u) {
    siz[u] = 1;
    max[u] = 0;
    for (auto &v : vec[u]) {
        dfs1(v);
        siz[v] += siz[u];
        if (siz[max[u]] < siz[v]) {
            max[u] = v;
        }
    }
}

int rt[max_N];

void merge(int u, int &rt) {
    SegmentTree::modify(l[u], r[u], rt);
    for (auto &v : vec[u]) {
        merge(v, rt);
    }
}

void dfs2(int u, int head) {
    if (max[u]) dfs2(max[u], head);
    for (auto &v : vec[u]) {
        if (v == max[u]) continue;
        dfs2(v, v);
        SegmentTree::rec(rt[v]);
        merge(v, rt[head]);
    }
    SegmentTree::modify(l[u], r[u], rt[head]);
    for (auto &i : qy[u]) {
        ret[i] = SegmentTree::query(ql[i], qr[i], rt[head]);
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v, L, R; i <= m; ++i) {
        scanf("%d%d%d%d", &u, &v, &L, &R);
        vec[u].push_back(v);
        p[v] = u;
        l[v] = L;
        r[v] = R;
    }
    p[1] = 0;
    l[1] = 1;
    r[1] = n;
    dfs1(1);
    scanf("%d", &q);
    for (int i = 1, x; i <= q; ++i) {
        scanf("%d%d%d", &x, ql + i, qr + i);
        qy[x].push_back(i);
    }
    dfs2(1, 1);
    for (int i = 1; i <= q; ++i) {
        printf("%lld\n", ret[i]);
    }
}
```