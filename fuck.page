```
#include <bits/stdc++.h>

const int moder = 998244353;
const int N = 100010;
const int M = 256;
const int K = 64;
const int BIT = 18;
const int TMP = 10000;

int powermod(int a, int exp){
    int ret = 1;
    for ( ; exp > 0; exp >>= 1){
        if (exp & 1){
            ret = 1ll * ret * a % moder;
        }
        a = 1ll * a * a % moder;
    }
    return ret;
}

int min[N], phi[N];
std::vector <int> prime;
bool invalid[M];
int trans[BIT][K][K];
int trans1[TMP][K][K];
int trans_to[K][4];
int cur[K], cur1[K];

int main(){
    phi[1] = 1;
    for (int i = 2; i < N; ++ i){
        if (!min[i]){
            min[i] = i;
            phi[i] = i - 1;
            prime.push_back(i);
        }
        for (auto u : prime){
            if (i * u >= N) break;
            min[i * u] = u;
            if (i % u == 0){
                phi[i * u] = phi[i] * (u - 1);
                break;
            }
            phi[i * u] = phi[i] * u;
        }
    }
    int n, m;
    scanf("%d%d", &n, &m);
    std::vector <int> fact;
    for (int i = 4; i <= n; ++ i){
        if (n % i == 0){
            fact.push_back(i);
        }
    }
    for (int i = 0; i < m; ++ i){
        int x = 0;
        std::vector <int> vec(4);
        for (int j = 0; j < 4; ++ j){
            scanf("%d", &vec[j]);
        }
        for (int j = 3; j >= 0; -- j){
            x = x * 4 + vec[j];
        }
        invalid[x] = true;
    }
    for (int i = 0; i < K; ++ i){
        for (int j = 0; j < 4; ++ j){
            int ni = i + (j << 6);
            if (!invalid[i] && !invalid[ni]){
                trans[0][i][ni / 4] = 1;
                trans_to[i][j] = ni / 4;
            }
            else{
                trans_to[i][j] = -1;
            }
        }
    }
    for (int u = 1; u < BIT; ++ u){
        for (int k = 0; k < K; ++ k){
            for (int i = 0; i < K; ++ i){
                for (int j = 0; j < K; ++ j){
                    trans[u][i][j] = (trans[u][i][j] + 1ll * trans[u - 1][i][k] * trans[u - 1][k][j]) % moder;
                }
            }
        }
    }
    for (int i = 0; i < K; ++ i){
        trans1[0][i][i] = 1;
    }
    for (int i = 1; i < TMP; ++ i){
        for (int j = 0; j < K; ++ j){
            for (int k = 0; k < 4; ++ k){
                int nj = trans_to[j][k];
                if (nj == -1){
                    continue;
                }
                for (int u = 0; u < K; ++ u){
                    int &w = trans1[i][nj][u];
                    w += trans1[i - 1][j][u];
                    w -= w >= moder ? moder : 0;
                }
            }
        }
    }
    int sum = 0;
    for (int i = 0; i < K; ++ i){
        memset(cur, 0, sizeof(cur));
        cur[i] = 1;
        int cur_pow = 3;
        for (auto u : fact){
            memset(cur1, 0, sizeof(cur1));
            int diff = u - cur_pow;
            if (diff < TMP){
                for (int j = 0; j < K; ++ j){
                    for (int k = 0; k < K; ++ k){
                        cur1[j] = (cur1[j] + 1ll * cur[k] * trans1[diff][j][k]) % moder;
                    }
                }
            }
            else{
                for (int bit = 0; bit < BIT; ++ bit){
                    memset(cur1, 0, sizeof(cur1));
                    if (!(diff >> bit & 1)){
                        continue;
                    }
                    for (int j = 0; j < K; ++ j){
                        for (int k = 0; k < K; ++ k){
                            cur1[j] = (cur1[j] + 1ll * cur[k] * trans[bit][j][k]) % moder;
                        }
                    }
                    memcpy(cur, cur1, sizeof(cur1));
                }
            }
            for (int j = 0; j < K; ++ j){
                bool flag = true;
                int x = j + (i << 6);
                for (int k = 0; k < 3; ++ k){
                    if (invalid[(x >> (k * 2)) & 255]){
                        flag = false;
                        break;
                    }
                }
                if (flag){
                    sum = (sum + 1ll * cur1[j] * phi[n / u]) % moder;
                }
            }
            cur_pow = u;
            memcpy(cur, cur1, sizeof(cur1));
        }
    }
    for (int i = 1; i <= 3; ++ i){
        if (n % i){
            continue;
        }
        for (int j = 0; j < 1 << (i * 2); ++ j){
            std::vector <int> tmp(8);
            int x = j;
            for (int k = 0; k < i; ++ k){
                tmp[k] = x % 4;
                x /= 4;
            }
            for (int k = i; k < 8; ++ k){
                tmp[k] = tmp[k % i];
            }
            bool flag = true;
            for (int k = 0; k < 4; ++ k){
                int x = 0;
                for (int u = k + 3; u >= k; -- u){
                    x = x * 4 + tmp[u];
                }
                if (invalid[x]){
                    flag = false;
                    break;
                }
            }
            if (flag){
                sum += phi[n / i];
                sum -= sum >= moder ? moder : 0;
            }
        }
    }
    sum = 1ll * sum * powermod(n, moder - 2) % moder;
    printf("%d\n", sum);
    return 0;
}
```