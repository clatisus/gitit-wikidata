```c++
#include <bits/stdc++.h>

const int moder = 998244353;
const int N = 20;
const int M = 4000010;

int l[N], r[N];
int inv[M];

int getinv(int i){
    if (i < M){
        return inv[i];
    }
    return moder - 1ll * (moder / i) * getinv(moder % i) % moder;
}

void solve(int n){
    typedef std::pair <int, int> pii;
    std::vector <pii> vec;
    vec.push_back({0, 1});
    for (int i = 0; i < n; ++ i){
        scanf("%d%d", &l[i], &r[i]);
    }
    for (int i = 0; i < n; ++ i){
        std::vector <pii> tmp;
        for (auto u : vec){
            tmp.push_back({u.first + l[i], u.second});
            tmp.push_back({u.first + r[i] + 1, -u.second});
        }
        vec = tmp;
    }
    std::sort(vec.begin(), vec.end());
    int prob = 0, expe = 0, comb = 1;
    int sz = vec.size();
    int ans = 0;
    for (int i = sz - 1, now = -1; i >= 0; -- i){
        if (vec[i].first > 0){
            continue;
        }
        while (now < -vec[i].first){
            ++ now;
            if (now > 0) {
                comb = 1ll * comb * (n - 1 + now) % moder * getinv(now) % moder;
            }
            prob += comb;
            prob -= prob >= moder ? moder : 0;
            expe = (expe + 1ll * comb * now) % moder;
        }
        ans = (ans - (expe + 1ll * vec[i].first * prob)) % moder;
    }
    const int MAX = 15000100;
    comb = 1;
    int comb1 = 1;
    for (int i = sz - 1, now = -1, now1 = -1; i >= 0; -- i){
        while (now < MAX - vec[i].first) {
            ++now;
            if (now > 0) {
                comb = 1ll * comb * (n - 1 + now) % moder * getinv(now) % moder;
            }
            prob += comb;
            prob -= prob >= moder ? moder : 0;
            expe = (expe + 1ll * comb * now) % moder;
        }
        if (vec[i].first < 0){
            while (now1 < -vec[i].first - 1){
                ++now1;
                if (now1 > 0) {
                    comb1 = 1ll * comb1 * (n - 1 + now1) % moder * getinv(now1) % moder;
                }
                prob -= comb1;
                prob += prob >= moder ? moder : 0;
                expe = (expe - 1ll * comb1 * now1) % moder;
            }
        }
        ans = (ans + (expe + 1ll * vec[i].first * prob)) % moder;
    }
    ans += ans < 0 ? moder : 0;
    for (int i = 0; i < n; ++ i){
        ans = 1ll * ans * getinv(r[i] - l[i] + 1) % moder;
    }
    printf("%d\n", ans);
}

int main(){
    inv[1] = 1;
    for (int i = 2; i < M; ++ i){
        inv[i] = moder - 1ll * (moder / i) * inv[moder % i] % moder;
    }
    int n;
    scanf("%d", &n);
    solve(n);
    return 0;
}

```