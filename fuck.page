#include <bits/stdc++.h>

const int max_N = 200010;

int n;
struct SAM {
    int tot, root, last;

    int go[max_N * 2][26], par[max_N * 2], len[max_N * 2];

    int new_node(int L) {
        int x = ++tot;
        memset(go[x], 0, sizeof go[x]);
        par[x] = 0;
        len[x] = L;
        return x;
    }

    void init() {
        tot = 0;
        root = last = new_node(0);
    }

    int extend(int c) {
        int p = last;
        int np = last = new_node(len[p] + 1);
        par[np] = root;
        for (; p && !go[p][c]; p = par[p]) {
            go[p][c] = np;
        }
        if (p) {
            int q = par[np] = go[p][c];
            if (len[q] != len[p] + 1) {
                int nq = ++tot;
                memcpy(go[nq], go[q], sizeof go[q]);
                par[nq] = par[q];
                par[q] = par[np] = nq;
                len[nq] = len[p] + 1;
                for (; p && go[p][c] == q; p = par[p]) {
                    go[p][c] = nq;
                }
            }
        }
        return np;
    }
} sam;

char s[max_N];

const int inf = 0x3f3f3f3f;

struct node {
    int val, mx[2], ls, rs;

    node() : val(inf), ls(0), rs(0) {
        mx[0] = inf;
        mx[1] = -inf;
    }
} T[max_N * 45];

#define mid ((l + r) >> 1)

void update(int x) {
    int ls = T[x].ls, rs = T[x].rs;
    T[x].val = std::min(T[ls].val, T[rs].val);
    if (T[ls].mx[0] < inf && T[rs].mx[0] < inf) {
        T[x].val = std::min(T[x].val, T[rs].mx[0] - T[ls].mx[1]);
    }
    T[x].mx[0] = std::min(T[ls].mx[0], T[rs].mx[0]);
    T[x].mx[1] = std::max(T[ls].mx[1], T[rs].mx[1]);
}

int merge(int x, int y, int l, int r) {
    if (!x || !y) {
        return x + y;
    }
    if (l == r) {
        return x;
    }
    T[x].ls = merge(T[x].ls, T[y].ls, l, mid);
    T[x].rs = merge(T[x].rs, T[y].rs, mid + 1, r);
    update(x);
    return x;
}

int tot;

void build(int &x, int l, int r, int p) {
    x = ++tot;
    T[x].mx[0] = T[x].mx[1] = p;
    if (l == r) {
        return;
    }
    if (p <= mid) {
        build(T[x].ls, l, mid, p);
    } else {
        build(T[x].rs, mid + 1, r, p);
    }
}

std::vector<int> vec[max_N * 2];

int rt[max_N * 2];

long long p = 1, q = 1;

void dfs(int u) {
    for (const int& v : vec[u]) {
        dfs(v);
        rt[u] = merge(rt[u], rt[v], 1, n);
    }
    int diff = T[rt[u]].val;
    if (diff < inf) {
        int np = sam.len[u] + diff;
        int nq = diff;
        if (p * nq < np * q) {
            p = np;
            q = nq;
        }
    }
}

int main() {
    scanf("%s", s);
    n = strlen(s);
    sam.init();
    for (int i = 1; i <= n; ++i) {
        int pos = sam.extend(s[i - 1] - 'a');
        build(rt[pos], 1, n, i);
    }
    for (int i = 2; i <= sam.tot; ++i) {
        vec[sam.par[i]].push_back(i);
    }
    dfs(sam.root);
    auto g = std::__gcd(p, q);
    p /= g;
    q /= g;
    printf("%lld/%lld\n", p, q);
    return 0;
}